<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[eventEmitter的实现]]></title>
    <url>%2F2018%2F04%2F26%2FeventEmitter%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[半个月前看到一篇文章将eventEmitter，看完之后心血来潮自己写了一个。晚上睡觉前忽然想到还可以尝试实现vue中emitter。于是，故事就这么开始了。 1、实现一个eventEmiiter1.1、整体架构 一个EventEmitter类的内容其实并不复杂，根据这张图来看，我们大致可以分为以下几个模块。 EventEmitter初始属性 _events //存储所有的监听器 _maxListeners setMaxListeners getMaxListeners listeners eventNames addEventListener模块 addListener prependListener once prependOnceListener on emit模块 emitNone emitOne emitTwo emitThree emitMany error 事件 removeEventListener模块 removeListener removeAllListeners listeners,eventNames listeners //获取一个监听器下的所有事件 eventNames //获取有哪些监听器 工具函数和兼容性函数 spliceOne arrayClone objectCreatePolyfill objectKeysPolyfill functionBindPolyfill 基本上按照上面这个顺序，就可以写出来一个基本的的eventEmitter的类了。推荐大家可以先自己尝试一下，这样子看成熟库的源码可以得到的收获更多。 只不过自己的代写的代码终究不够完善，所以，然后去网上找了一个成熟库的源码进行对比，也发现了一些问题 点这里。写完之后，可以看下看EventEmitter类源码怎么实现的。 自己为了节省代码行数，单个事件和多个事件都用了Array去存储。其实作为库，节约的十几行代码和性能比起来，还是后者更重要 没有考虑emit几个参数的情况，不同情况的处理有助于提高性能 没有考虑限制一个类可以绑定的最大事件数。因为如果数目一多话，容易造成内存泄露. 函数缺少对参数的判断。缺少防御性代码 1.2、简单分析一下部分代码具体代码就不分析，因为源码并不复杂,沉下心花个半小时肯定能全部看懂。不过中间还是有很多细节可以值得讨论的。 1.2.1、为什么使用Object.create(null)我们可以看到网上许多库(比如vue)都是使用Object.create(null)来创建对象，而不是使用{}来新建对象。这是为什么呢？ Object.create()这个API我就不介绍了，不知道的可以上MDN上自己看 我们可以先在chrome的控制台上打印{}创建的对象是什么样子的： 可以看到新创建出来的对象继承了Object原型链上所有的方法。 我们可以再看一下使用Object.create(null)创建出来的对象: 没有任何属性，显示No properties。 那么问题来了，这么一个干净的对象有什么好处呢。 首先我们需要知道无论是var a = {}还是Object.create({})，他们返回的都是一个继承Object的原型的对象。但是假如有别的库或者开发者在页面上修改了Object的原型，那么你也会继承下来修改后的原型方法，这个可能就不是我们想要的了。 随后在一个csdn的网页控制台写个例子，没想到就出现这个问题 而如果我们自己在每个库开头新建一个干净的对象，我们可以自己改写方法自己复用继承，既不会被他人影响，也不会影响他人。 1.2.2、比原生splice效率还高的函数在源码中看到了这么一段代码，作者亲自打了注释说1.5倍速度快于原生。123456// About 1.5x faster than the two-arg version of Array#splice().function spliceOne(list, index) &#123; for (var i = index, k = i + 1, n = list.length; k &lt; n; i += 1, k += 1) list[i] = list[k]; list.pop();&#125; splice的效率慢我是知道，但是作者说1.5倍快我就要亲自试验下了。看他方法，应该是数组长度越长，所需时间越长;下标越靠近开始，所需时间越长。于是我用了不同长度的数组，不同下标去进行反复测试100次。 123456789101112131415// 测试的代码是这么写的，如果不合理请指教var arr = [];for(let i = 0;i &lt; 50000;i++)&#123;arr.push(i)&#125;console.time();spliceOne(arr,1)// arr.splice(1,1)// arr.splice(49995,1)// spliceOne(arr,49995)console.timeEnd() //在数据长度是5的情况下,下标为1，splice效率快33%//在数据长度是500的情况下，下标为1，splice效率快75%//在数据长度是50000的情况下，下标为1，splice效率快95%//在数据长度是5的情况下,下标为4，spliceOne效率快20%//在数据长度是500的情况下，下标为45，spliceOne效率快50%//在数据长度是50000的情况下，下标为49995，spliceOne效率快50% 因为源码是针对node.js的，不知道是不是浏览器内部对splice做过优化。作者的方法在特定情况下的确是做到了更快，还是很厉害的。 1.2.3、多个emit方法源码作者专门为emit不同数量参数写了不同的方法,有emitNone,emitOne,emitTwp,emitThree,emitMany。 如果按照我来写，最多也就分成emitNone和emitMany两个方法。但是作者应该是为了更高的效率，尽可能减少for循环这种代码。这也是我这种不怎么写库的人迟钝的地方。节约的十几行代码在压缩之后，重要性是低于性能上的损耗的。 2、简单实现vue中的EventEmitter在写完EventEmitter之后，仍然感觉特别单调。然后睡觉的时候忽然在想，是不是可以正好将自己写好这个类套进到vue里面呢？有了实际场景，就知道自己写的东西到底能干什么，有什么问题。不然空有理论也是没有任何进步的。 之前网上也有很多文章解析了vue如何实现双向绑定。事实上在编译html的过程中实现了的不仅仅是数据双向绑定，添加事件监听器也是这一过程做的。只是网上有很多关于vue数据双向绑定的文章很多，但是关于事件监听的却几乎没有。 2.1、自己尝试实现一个vue中的EventEmitter按照vue编译的流程，应该是在编译HTML获取所有的属性，判断出哪些属性是绑定事件，哪些是数据绑定。12345678910111213141516171819202122232425&lt;template&gt; &lt;div id=&quot;app&quot; :data=&quot;data&quot; @click=&quot;test&quot; @change=&quot;test2&quot;&gt;test内容&lt;/div&gt;&lt;/&gt;&lt;script&gt;var vue = &#123; methods: &#123; test()&#123;alert(123)&#125;, test2()&#123;console.log(456)&#125; &#125;&#125;var onRE = /^@|^v-on:/;function compile(node) &#123; var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/; //节点类型为元素 if(node.nodeType === 1)&#123; var attr = node.attributes; for(var i = 0;i &lt; attr.length; i ++)&#123; console.log(attr[i]) &#125; &#125;&#125;compile(window.app)&lt;/script&gt; 于是自己先写出了第一段代码,希望依靠原生node的方法attributes去获取DOM元素上所有的属性 但是等到获取之后，才发现获取到的每个属性attr[i]竟然是一个神奇的对象类型[object Attr]，表现形式是@click=test。虽然表现很像是字符串，但是个NamedNodeMap 去网上找了资料之后，才知道他是怎么获取key和value的。1234567891011121314var onRE = /^@/;function compile(node) &#123; var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/; //节点类型为元素 if(node.nodeType === 1)&#123; var attr = node.attributes; for(var i = 0;i &lt; attr.length; i ++)&#123; if(onRE.test(attr[i].nodeName))&#123; var value = attr[i].nodeValue; &#125; &#125; &#125;&#125;compile(window.app) 只是文章里面说DOM4规定中已经不推荐使用这个属性了。想了想还是放弃了。还是乖乖去看了一下vue的源码是怎么实现的吧 2.2、vue源码实现一个EventEmitter因为想着vue肯定也是先编译HTML，所以直接找到了源码中的html-parse模块。 vue先定义了一个parseHTML的方法，传进来需要编译的html模板，也就是我们的template。然后通过前面的正则表达式一步步去match出模板字符串内的所有属性，最后返回了一个包含所有属性的数组attrs。 接着对数组attrs进行遍历判断，比如是v-for，还是change,还是src等等。当获取到的属性为@click或者v-on:click这种事件之后，然后通过方法addHandler去添加事件监听器。我们也就可以在开发中使用emit了。 当然vue中间还会有很多操作。比如会接着将这个属性数组以及tag传入到一个createASTElement函数里面进行生成一棵AST树渲染成真实的dom等等。只不过这并不是我们本篇文章需要讨论的内容了 我们接下去就按照vue的流程来实现绑定事件。首先我们定义好我们的html内容。123456789101112131415&lt;template&gt; &lt;div id=&quot;app&quot; :data=&quot;data&quot; @click=&quot;test&quot; @change=&quot;test2&quot;&gt;test内容&lt;/div&gt;&lt;/&gt;&lt;script&gt;var vue = &#123; data()&#123; return &#123;data:1&#125; &#125; methods: &#123; test()&#123;alert(123)&#125;, test2()&#123;console.log(456)&#125; &#125;&#125;&lt;/script&gt; 接着我们就要开始进行编译之前，我们准备好所有需要用到的正则，新建好一个eventEmitter类 123456789var attribute = /^\s*([^\s&quot;&apos;&lt;&gt;\/=]+)(?:\s*(=)\s*(?:&quot;([^&quot;]*)&quot;+|&apos;([^&apos;]*)&apos;+|([^\s&quot;&apos;=&lt;&gt;`]+)))?/;var ncname = &apos;[a-zA-Z_][\\w\\-\\.]*&apos;;const qnameCapture = `((?:$&#123;ncname&#125;\\:)?$&#123;ncname&#125;)`const startTagOpen = new RegExp(`^&lt;$&#123;qnameCapture&#125;`)var startTagClose = /^\s*(\/?)&gt;/;var onRE = /^@|^v-on:/;var eventEmitter = new EventEmitter()const app = document.getElementById(&quot;app&quot;) 然后开始写我们的编译函数。前面已经说了，我们传进模板,然后依据正则一步步match出所有的属性.123456789101112131415161718function compiler(html)&#123; html = trim(html) //因为模板换行有空格，所以需要先去除开头的空格 let index = html.match(startTagOpen)[0].length html = html.substring(index) const match = &#123; attrs: [], attrList: [] &#125; let end, attr; //编译完整个html标签 //如果多层dom，vue有循环，但是测试就不搞那么复杂了 while (!(end = html.match(startTagClose)) &amp;&amp; (attr = html.match(attribute))) &#123; match.attrs.push(attr) index = attr.length html = html.substring(attr[0].length) &#125; return match&#125; 解释一下编译过程吧。先根据开头标签的正则，找到需要编译的html标签。然后截取出除开始标签&lt;div的剩余字符串。 接下来继续对字符串判断。依靠属性正则表达式，判断html有没有属性，如果有的话，从字符串中截取出来。 继续不断循环字符串，直到遇到闭合标签/div&gt;为止。然后结束编译，返回数组。 编译完成后我们已经获取到了模板里面所有的属性，但是现在存储起来的属性表现形式是一个match出来的数组，并不是一个方便开发者使用的map形式。所以接下来我们要处理一下我们获得的数组。123456789101112131415161718function processAttrs(match)&#123; let l = match.attrs.length for (var i = 0; i &lt; l; i++) &#123; var args = match.attrs[i]; // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778 if (args[0].indexOf(&apos;&quot;&quot;&apos;) === -1) &#123; if (args[3] === &apos;&apos;) &#123; delete args[3]; &#125; if (args[4] === &apos;&apos;) &#123; delete args[4]; &#125; if (args[5] === &apos;&apos;) &#123; delete args[5]; &#125; &#125; var value = args[3] || args[4] || args[5] || &apos;&apos;; match.attrList[i] = &#123; name: args[1], value: value &#125;; &#125; return match&#125; 通过这一步，我们已经获取到了一个attrList,并且存储起来了一个个表现为map形式的属性。然后我们要遍历这些属性，判断哪些是需要绑定的方法，哪些使我们不需要的属性。如果是需要绑定的方法，我们通过addHandler函数来添加事件监听器。12345678910111213141516171819function processHandler(match)&#123; let attrList = match.attrList, l = attrList.length let name, value for(let i = 0; i &lt; l; i ++)&#123; name = attrList[i].name value = attrList[i].value if(onRE.test(name))&#123; name = name.replace(onRE, &apos;&apos;); addHandle(vue, name, value, false); &#125; &#125;&#125;function addHandle(target, name, value, prepend)&#123; let handler = target.methods[value] eventEmitter.addListener(name, handler, prepend) eventEmitter.emit(&quot;click&quot;)&#125; 走到这里整个流程就已经结束了。接下去每次进入页面去进行初始化编译就好了。12345function parseHTML(html)&#123; const match = compiler(html) processAttrs(match) processHandler(match)&#125; 如果想尝试触发我们之前绑定的事件，在vue中是子组件向父组件触发。这里就不搞父子组件这么麻烦了。我们可以直接在JS里面调用emit来进行验证1eventEmitter.emit(&quot;click&quot;) game over文章结束了，日常总结一下吧。实现整个eventEmitter的代码其实并不复杂，尤其在源码非常简洁的情况下，基本上认真看个十几分钟就能明白整个轮廓。然后我没有仔细看vue中的实现是怎么样的，不过我猜测应该相似度很高。 后面看vue提取属性还是花了更多的时间，原来还以为可以自己通过attribute属性来实现的。没想到最后还是参考了vue，再看的途中，也明白了vue编译html的整个过程，以及每个过程实现了哪些内容。 其实看源码可以学到的东西都很多，最直接的就是知道怎么实现一个功能。此外呢？其实此外是是更多的。比如编码习惯，比如防御性代码怎么写，比如结尾处理代码怎么写，比这不就看到有方法比原生API的效率还快。这些都是看源码的乐趣所在。 看完之后，以后妈妈再也不用担心面试靠eventEmitter了]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>技术文章</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现一个自定义滚动条]]></title>
    <url>%2F2018%2F02%2F24%2F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%9A%E5%8A%A8%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[因为最近在写项目的UI库，遇到自定义滚动条这一个槛还是卡了我挺久的，主要卡在了如何自动监听内容变化并更新滚动条高度。市面上基本所有的滚动条插件都没有实现这一点，最后面扒了element的源码才最终解决。本文主要讲的也是这个。 首先，我们先把需要实现的功能先确定下来。 鼠标左键点击可以拖动 鼠标滑轮滚动 内容发生变化，自动更新滚动条长度 提供开发者一个滚动回调的接口 前面两点依靠原生滚动条其实比较简单，但是在第三点上实在是卡了我好久，想了好久都没有想出来。最后还是看了element源码才实现成功。 接下去我会以垂直滚动条为例(水平滚动条基本同理)，实现一个自定义的滚动条出来。我争取把其中原理细节讲清楚。 1、搭建好基本的样式框架开始我们先把HTML和样式写好 12345678910111213&lt;div class=&quot;scrollbar&quot;&gt; &lt;div class=&quot;scrollbar-content&quot;&gt; &lt;ul class=&quot;box&quot;&gt; &lt;li&gt;11111&lt;/li&gt;&lt;li&gt;11111&lt;/li&gt;&lt;li&gt;11111&lt;/li&gt;&lt;li&gt;11111&lt;/li&gt; &lt;li&gt;11111&lt;/li&gt;&lt;li&gt;11111&lt;/li&gt;&lt;li&gt;11111&lt;/li&gt;&lt;li&gt;11111&lt;/li&gt; &lt;li&gt;11111&lt;/li&gt;&lt;li&gt;11111&lt;/li&gt;&lt;li&gt;11111&lt;/li&gt;&lt;li&gt;11111&lt;/li&gt; &lt;li&gt;11111&lt;/li&gt;&lt;li&gt;11111&lt;/li&gt;&lt;li&gt;11111&lt;/li&gt;&lt;li&gt;11111&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&apos;scrollbar-bar&apos;&gt; &lt;div ref=&quot;thumb&quot; class=&quot;scrollbar-thumb&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 第一步的HTML和CSS 滚动条的框架如上面所示，接下午我会以简称wrap，bar,thumb进行简称 wrap ：内容区域包裹框 bar ： 包裹区域中自定义滚动条的滚动框 thumb ：自定义滚动条 开始之前要大家可以先记住一点，我们并不是不用原生滚动条，实际上我们所有的操作都需要依靠原生滚动条才能实现。只不过它隐藏在了暗处，而让UI更好看的自定义滚动条出现在明处。 1.1计算出滚动条的宽度。第一步我们先将原生的滚动条隐藏掉。但是这里涉及到第一个问题，那就是不同浏览器的下滚动条宽度是不一样的。我们需要准确的知道，如果wrap产生了滚动条，那它的宽度是多少。 先写一个获取到区域内滚动条的宽度（scrollWidth）的回调函数getScrollWidth,获取到滚动条高度之后，12345678910111213141516171819202122function getScrollWidth()&#123; const outer = document.createElement(&quot;div&quot;); outer.className = &quot;el-scrollbar__wrap&quot;; outer.style.width = &apos;100px&apos;; outer.style.visibility = &quot;hidden&quot;; outer.style.position = &quot;absolute&quot;; outer.style.top = &quot;-9999px&quot;; document.body.appendChild(outer); const widthNoScroll = outer.offsetWidth; outer.style.overflow = &quot;scroll&quot;; const inner = document.createElement(&quot;div&quot;); inner.style.width = &quot;100%&quot;; outer.appendChild(inner); const widthWithScroll = inner.offsetWidth; outer.parentNode.removeChild(outer); scrollBarWidth = widthNoScroll - widthWithScroll; return scrollBarWidth;&#125; 获取到滚动条的宽度scrollBarWidth之后，通过再来设置wrap的css样式，通过marginRight将滚动条移动到视线之外12wrap.style.overflow = scroll;wrap.style.marginRight = -scrollWidth + &quot;px&quot;; 1.2计算出滚动条的高度。第二步我们需要计算出滚动条的高度。计算方法也很简单，元素高度scrollHieght/内容高度clientHeight，得出来的就是滚动条所占的百分比。 因为内容高度经常变更，我们可以写一个更新滚动条高度的回调函数updateThumb，方便后期随时调用。1234function updateThumb()&#123; let heightPercentage = (wrap.clientHeight * 100 / wrap.scrollHeight); thumb.style.height = heightPercentage + &quot;%&quot;; &#125; 到了这一步，基本上一个滚动条的基本样式已经出来了。接下去我们要实现它的使用功能。 查看第一步的成果 2、添加滚动条滑动功能到这里我们已经可以看到成型的滚动条的UI界面了，但是仍然缺少滚动和拖动的功能。关键点是在于如何去监听滚动条的变化。 2.1滚轮滑动还记得文章开头说过，我们所有功能的实现都依赖隐藏起来的原生滚动条。如果大家理解了我上面说的话，那么问题就简单了。当我们开始滑动滚轮的时候，隐藏在暗处的原生滚动条也会同时滚动，此时便会触发原生滚动条的scroll事件。 这里可以再详细说明下。只要元素的scrollTop发生变化，就必然会触发scroll事件。所以我们操作滚轮，其实本质上是改变元素的scrollTop。 所以我们只需要写一个相应的回调函数handleScroll，在每次触发回调的时候，实时修改我们自定义滚动条的样式就行了。 123456function handleScroll()&#123; this.moveY = (wrap.scrollTop *100 / wrap.clientHeight); //通过计算出来的百分比，然后对滚动条执行translate移动 thumb.style.transform = &quot;translateY&quot; + moveY;&#125;,wrap.addEventListener(&apos;scroll&apos;,handleScroll); 查看滚轮滑动效果 2.2点击滚动框，滚动条及内容移动到相应位置接下去我们实现第二个功能。当我们点击滚动框的一个位置时，滚动条也会跳到这个位置，同时内容位置也会发生改变。 第一步先获得点击的y坐标,然后计算出和滚动框bar顶部的距离，通过这段距离占滚动框bar的百分比去获取scrollTop值。123456789101112function clickTrackHandle(e)&#123; //获得点击位置与滚动框顶部之间的距离 const offset = Math.abs(e.target.getBoundingClientRect().top - e.clientY) //让点击位置处于滚动条的中间 const thumbHalf = thumb.offsetHeight / 2; //计算出滚动条在滚动框的百分比位置 const thumbPositionPercentage = (offset - thumbHalf) * 100 / wrap.offsetHeight; //通过改变scrollTop来操作。所有操作滚动条的最后一步都是通过handleScroll来实现 wrap.scrollTop = (thumbPositionPercentage * wrap.scrollHeight / 100);&#125;bar.addEventListener(&quot;click&quot;,clickTrackHandle); 只要scrollTop值发生变化就会触发我们上一步写的回调。 查看点击滚动框的效果 2.3拖动滚动条，移动内容接下来我们再去实现手动拖拽滚动条去实现移动内容，这个知识点就是拖拽的知识点，不过在看源码的时候发现element的习惯很好，他是在当你点击滚动条的时候绑定拖拽,然后松开的时候取消绑定。12345678function mouseMoveDocumentHandler()&#123;&#125;; //实时记录滚动条位置的拖拽函数//当点击滚动条时document.addEventListener(&quot;mousedown&quot;,mouseMoveDocumentHandler);document.onselectstart = false; //同时阻止选中//当松开滚动条时document.removeEventListener(&quot;mousedown&quot;,mouseMoveDocumentHandler);document.onselectstart = null; //同时阻止选中 因为这一块代码比较多，就不贴文章里，大家可以直接链接里看就是了。基本上到了这一步，已经实现了市面上自定义滚动条的效果了。下面就是解决卡了我的好久的实时更新问题了。 查看自定义滚动条的效果 3、实现滚动条随内容实时更新第二章讲的主要都是实现滚动条功能，这一章讲的是纠结😖我很久的功能。 因为滚动条的高度并不是我们一开始能够确定的，它需要在dom内容渲染出来之后才能确定。而且有时候随着内容的变化，还需要实时改变滚动条的高度。再看了市面上的滚动条之后，发现基本都没有满足这一功能。 事实上缺少了这一点，使用起来是缺少视觉交互的。举个例子，加入一个原来有滚动条的元素因为内容减少导致了滚动条小时，但是自定义滚动条因为没有检测到变化仍然存在，那就会给用户造成困扰。 我不希望每次更新内容都要通过加一步回调函数来更新一下滚动条，而是希望它自己实时更新。在网上没有找到答案之后，最终去翻了element源码，研究了好久，总算找到了想要的答案。 关键点就在于我能前面之前说的那一句话——如果我们改变元素的scrollTop，是会触发scroll事件。 大家想象一个情景，如果滚动条永远出现在最底部，比如下图 那么只要我内容发生了一点变化，滚动条必然会变长或者变短。那么在滚动条长度变化时，scrollTop自然发生了改变（滚动条消失则scrollTop变为0），那么就会触发scroll的回调函数，那么我们就自动监测到了啊😊。 在明白了这一点后，却又冒出来一个问题。正常情况下，滚动条不可能出现在最底部啊，那怎么办呢？ element选择了自己造一个置于底部的滚动条来满足自己需求。我也学习者element的方法进行实现。 最终实现查看效果点这里 12345678910111213141516171819&lt;script&gt; const ul = document.getElementById(&quot;ul&quot;); const resizeTrigger = document.createElement(&quot;div&quot;); resizeTrigger.className = &quot;resize-triggers&quot;; resizeTrigger.innerHTML = &apos;&lt;div class=&quot;expand-trigger&quot;&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&apos;; ul.appendChild(resizeTrigger); const resetTrigger = function (element) &#123; const trigger = element.__resizeTrigger__; const expand = trigger.firstElementChild; const expandChild = expand.firstElementChild; expandChild.style.height = expand.offsetHeight + 1 + &apos;px&apos;; expand.scrollTop = expand.scrollHeight; &#125;; ul.addEventListener(&quot;scroll&quot;,function()&#123; resetTrigger(this); &#125;,true)&lt;/script&gt; ul是我们包裹内容的DOM元素。 配合着css来看，第一段JS我们创建出了resizeTrigger这个div,并且我们将他的height:100%。这样子如果内容发生变化，resizeTrigger永远和父元素ul同时改变高度。这里设置成高度100%非常重要，这样子才能主动同步到内容的变化。 注意到resizeTrigger里面还有有一个父子元素expand和expandChild。在第二段JS的resetTrigger函数中。然后设置expandChild的高度超过父元素expand的高度，促使expand产生滚动条。然后我们再将滚动条的scrollTop设置为最大,这样子滚动条就会出现在滚动区域resizeTrigger的最底部了。 现在我们做到了将滚动条设置在了最底部，所以只要内容发生了变化，那么滚动条的scrollTop必然也会发生变化。 最后一段代码就是scroll的监听。当监听到scrollTop值发生变化时，触发相应的回调函数。 所以这块代码最后的逻辑其实是这样的。内容改变 –&gt; ul高度改变–&gt; resizeTrigger高度改变 –&gt; expand滚动条的scrollTop发生变化 –&gt; 触发scroll的回调函数，在函数里面调整再次调整滚动条的高度，保证滚动条高度正确。 通过这三段代码，我们也基本实现了自动监听内容变化来更新滚动条。 简单画了个配图来帮助理解逻辑 通过两个小蓝框产生的滚动条来帮助监听内容变化 4、实现组件化，方便开发者使用经过以上3大步基本上是可以实现一个自定义的滚动条的。上面的代码是面向原生js的。在我们的项目里面，实现第4点是通过封装成一个scrollbar的的组件，在项目里面进行使用。 这一条要求因为不同框架实现方式都不一样，所以就不详细贴代码了，不过最终原理肯定还是一样的。因为自己项目用的是一个Vue框架，所以是个Vue组件，有需求可以自己去看。 没有写过写Vue组件的可以看看这一篇，少踩些坑 查看scrollbar组件 好了文章就到此结束了，在看人家源码的过程中也学到了许多。比如使用JSX来编写组件；scroll监听其实就是判断scrollTop；比如通过自己造滚动条的方法监听scrollTop来实现自动更新。最后通过写文章，对一些新的知识点理解还是加深了许多。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>技术文章</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《浪潮之巅》读后感]]></title>
    <url>%2F2018%2F01%2F29%2F%E3%80%8A%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[先简单的写一下每一章读完后的简单读后感，然后简单的总结一下吧 第1章 帝国的余晖—AT T公司1.一个公司的长远发展不应该为眼前的利益所耽误。在华尔街的影响之下，不得不接连为满足上市公司的利益不断拆分，合并，最后消亡。 2.没有跟上时代的趋势，在传统电话与移动电话交接的关键期，拥有充足资金和先进技术，但是却因为业务的拆分直接被时代快速拉下来了。 3.一个想要长久发展的公司必然需要一个强势为公司长远考虑的领导人。 第2章 蓝色巨人—IBM公司1.IBM作为一个走过百年的公司，拥有许多传统并且占有垄断优势的业务，才可以不断的去尝试新的方向。 2.新兴创业公司如果贸然学习传统公司多方向出击，反而会容易失去原有的优势，得不偿失。所以第三点↓。 3.公司需要不断深耕自己的核心领域，加强优势。 第3 章 “水果”公司的复兴—苹果公司1.不断积累自己的优势，准确的把握未来的趋势，明确自己的核心竞争力，不断创新出用户所需要的，并且将其做到极致 2.死而复生的苹果公司和乔布斯 第4 章 计算机工业的生态链1.摩尔定律。必须不断的加快自己的研发进度，以保证公司不会因为没有及时跟上下一代产品导致市场和利润率下降。 2.安迪-比尔定律。硬件的不断更新会推动软件的不断创新。为了更多的软件创新，反过来会逼迫硬件不断发展来满足使用软件的需求。 3.反摩尔定律。逼迫公司不断加大研发来保证自家产品可以跟上市场的速度。 第5 章 奔腾的芯— 英特尔公司1.明确所有计算机公司的共同需求之后，选择其中一块领域进行深耕，不断加强自己的垄断优势。（当然需要明确自己的方向是符合时代趋势的，不然也是扯淡。 2.在自己的发展过程中，也许小方向有问题，不过如果能把快速所有对手都干掉的话，也足够自己来纠正方向（指令集之争）。忽然想到了现在的烧钱抢市场。 第6 章 IT 领域的罗马帝国— 微软公司1.成长期的腾讯和成长期的微软非常相似，希望能够占领所有的市场，看见什么就做什么，并且依靠操作系统的地利优势，往往能够快读打败对手。 2.早期依托地利优势打败网景的浏览器，成功握住了互联网2.0的入口。但是因为没有重视入口，在近年已经被chrome打败了。 3.一旦有了稳定的盈利点，并且市场足够大的话，那么只要随着时间发展，必然有巨大的利润。 4.在微机时代依托操作系统的优势，成功站在了浪潮之巅。但是在后来的软件之争中却不断失败退守。 5.把握住计算机的核心，依靠地利优势，快速在初期占领了很大的软件市场。 6.老业务在公司占有主导权的时候，会阻碍新业务的发展。比如办公软件部门的强势就很难使公司有资金去做MSN这一类的免费商业模式。 第7 章 纯软件公司的先驱— 甲骨文公司1.以点带面，把握住一个巨头没有重点关注的市场，快速拥有核心优势，击败主要竞争对手，做到垄断市场。感觉和今日头条很像，一开始依靠新闻领域，占领二三线市场，今天的今日头条手上已经有了多个巨大流量入口的APP。 第8 章 互联网的金门大桥— 思科公司1.公司创立之初，便拥有巨大的技术优势，同时所做的事情既是符合时代趋势，还没有竞争对手，这样的公司能不站在浪潮之巅吗？。 2.不过当这三点优势都没有了之后，成长便慢慢趋于停滞了。 3.自己资助内部人创业，帮助他们的同时，既是消灭了隐藏的对手，又是壮大了自己。 第9 章 英名不朽—杨致远、费罗和雅虎公司1.有着甲骨文的侵略性，但是又因为没有有远见的领导人。不断并购，盲目扩张合并，结果两个不好的公司合并，反而离第一名越来越远。 2.华尔街的压力对一个公司长远的发展实在是影响太大了 3.业务太多太杂，在面对更加专注的公司而不断惨败。 第10 章 硅谷的见证人— 惠普公司1.强烈的证明了两家差的公司合并，只会将问题越来越多。 2.公司所代表的趋势，决定了你会吸引什么样的人才。 第11 章 没落的贵族— 摩托罗拉公司1.当一家公司的先天优势与未来趋势相反的时候，真的很难下决定放弃自己的优势扑向一个大家都是起点的领域。 2.一家公司不够专注，太多的页面，多线战争反而使其在每一个领域都没有优势，最后便是全面溃败。 3.再次强调一位好的领导人的重要性。 第12 章 硅谷的另一面1.成王败寇 2.嗜血的地方 3.机会均等 第13 章 短暂的春秋—与机会失之交臂的公司在人类命运降临的伟大瞬间，市民的一切美德——小心、顺从、勤勉、谨慎，都无济于事。它始终只要求天才人物，并且将他造就成不朽的形象。命运鄙视地把畏首畏尾的人拒之门外。命运——这世上的另一位神，只愿意用热烈的双臂把勇敢者高高举起。 1.太阳公司 2.Novell 公司 3.网景公司 4.RealNetworks 第14 章 幕后的英雄— 风险投资对于想找投资的新创业公司，红杉资本有一些基本要求——公司的业务要能几句话就讲清楚。红杉资本的投资人会给你一张名片，看你能不能在名片背面的一点点地方把你想做的事情写清楚。 1.风投的起源 2.风投的结构 3.风投的过程 4.投资的决策和公司的估价 5.风险投资就是投人 6.风投的角色 7.著名的风投公司 第15章 信息产业的规律性1.70–20–10律。老大拥有最多的市场，最大的利润，它能够决定趋势的走向，是市场规则的制定者和解释着。老二，老三虽然偶尔能扑起一朵朵的小浪花，但是已经很难翻身了。 2.诺威格定律。当一个公司在市场占有主导地位（50%以上），因为已经无法做到翻一番，所以需要不断去开创新的财路，才能保证公司长盛不衰。 3.基因决定定律。深耕系统，大型机和服务的IBM很难在PC市场上成功。因为老业务在公司占有主导权的时候，会阻碍新业务的发展 4.有时候，公司产品的周边从业者反而会比公司更加捍卫自己的产品，并不断打压别的挑战者。因为这是在维护自己的饭碗。可以去培育用户，有点像小米之家。 第16 章 硅谷的摇篮—斯坦福大学二战后，帮助斯坦福大学解决财政危机的是它的一位教授弗里德里克·特曼，他后来被称为“硅谷之父”。他仔细研究了斯坦福夫妇的遗嘱，发现里面没有限制大学出租土地，于是他兴奋地声称找到了解决问题的秘密武器——建立斯坦福科技园。 1.充满传奇的大学 2.硅谷的支柱 3.纽曼加洪堡的教育模式 4.创业的孵化器 第17章 科技公司的吹鼓手—投资银行华尔街的贪婪既会捧起，也会扼杀一个科技新星。1.华尔街和美国的金融体系 2.著名的投资公司 3.科技公司的上市过程 4.成也萧何，败也萧何 5.华尔街与微软、雅虎和Google 的三国演义 金融危机来临前的征兆，比如很多不需要融资的投资公司也上市融资。因为那些银行家比我们看的更远。 第18 章 挑战者— Google 公司1.如果是三等工程师，那么谷歌根本不需要。 2.绝代双骄。优秀的领导人。 3.一开始就有长远目光的打算。 4.早期在与人竞争的时候，显得更加关注。比如和雅虎在竞争搜索，不说谷歌做的怎么样，先看看雅虎做的怎么样吧。 5.在招人方面精益求精，瑞士军刀的品质 6.与其担心对手在自己的优势领域抢占市场，不如主动出击，将战线推到对方的优势领域。 第19 章 成功的转基因—诺基亚、3M、GE 公司1.放弃现有的优势，押注虚无缥缈的未来是很难的。 第20 章 印钞机— 最佳的商业模式1.弄一个很低的门槛，可以帮你过滤出有真正需求的人。比如只是付费的一块钱门槛。 2.戴尔的“虚拟工厂”。怎么样做到成本最低，利润最高。就是尽可能的压缩产品线所有环节，使资金做到收回最快，利用率最高。 第21 章 互联网2．01.维基百科，youtube，facebook的例子都证明了一点，在互联网2.0时代，每个人都是互联网的参与者。他们既是内容的提供者，也是内容的消费者。 2浏览器成为了人们上网最快，最方便的方式，成为了互联网2.0的入口，，满足了人们快速上网的基本需求。那么下一个入口在哪？ 第21 章 金融风暴的冲击1.优胜劣汰。金融危机可以帮助好的公司以极低的成本收购到那些泡沫公司。使那些差的公司无法维持自己日益没落的统治地位。 2.金融危机后可以过滤出真正好的公司，既是危机，也是遍地黄金的机会。 浏览了一遍下来，发现新兴公司如果想要快速发展，如果符合以下三点，拥有技术优势，符合时代趋势，还没有竞争对手，那么往往可以在开头占有巨大的便宜。 但是要成为一个伟大的公司，初期的发展就换成了另外三句话，快速拥有核心优势，击败主要竞争对手，做到垄断市场。然后就是不断滚雪球，尝试多个相关方向的发展。 如果这时候再有一个英明的领导人，可以保证公司在10年内不会被人超越。 如果还能紧紧把握时代的趋势，这个就真的太难了，做到的公司最后才真的能够站在浪潮之巅。]]></content>
      <categories>
        <category>《浪潮之巅》</category>
      </categories>
      <tags>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一步步实现一个简单的router插件]]></title>
    <url>%2F2018%2F01%2F13%2F%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84router%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[单页应用在随着框架的诞生已经是大趋势，自己平时在项目中也已经用了不少vur-router的代码了。用久了自然对其中的实现好奇了起来，于是想着自己能不能做出一个简单的vue-router。一开始扒了源码研究，实在是看不懂。于是从一篇篇文章开始慢慢补充起自己的基础。 一、写一个最简单的前端路由如果使用过vue-router的人应该知道，Router插件是通过切换hash值来切换页面的。而浏览器则提供了一个hashchange的回调方法监听的hash值的变化。我们可以就这个原生API实现一个简单的前端路由。 之所以用这个API作为我们第一个出场嘉宾，其好处是可以兼容低版本的IE8浏览器 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;a href=&quot;#/&quot;&gt;home&lt;/a&gt;&lt;a href=&quot;#/router1&quot;&gt;router1&lt;/a&gt;&lt;a href=&quot;#/router2&quot;&gt;router2&lt;/a&gt;&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;--------class Router &#123; constructor(router = &#123;&#125;)&#123; this.router = router; this.init(); &#125; refresh()&#123; let url = window.location.hash.slice(1) || &quot;/&quot;; if(this.router[url])&#123; this.router[url](); &#125;else&#123; throw new Error(&quot;It isn&apos;t a router name that registered&quot;); &#125; &#125; init()&#123; window.addEventListener(&quot;hashchange&quot;,this.refresh.bind(this),false); &#125;&#125;function changeContent(text)&#123; document.getElementById(&quot;content&quot;).innerText = text;&#125;let router = new Router(&#123; &quot;/&quot;()&#123; changeContent(&apos;home&apos;) &#125;, &apos;/router1&apos;()&#123; changeContent(&apos;router1&apos;) &#125;, &apos;/router1&apos;()&#123; changeContent(&apos;router2&apos;) &#125;&#125;) 当浏览器监听到hash值发生改变之后，自动调用对应路由提供的回调，这样子就出现了一个简单的单页路由demo。 二、实现一个简单的H5版本的前端路由随着HTML5的发布，我们则多了一个新的选择history。 浏览器原生的history对象为我们提供了一些新的方法如下,具体意思基本上也可以做12345history.go(); //加载 history 列表中的某个具体页面。history.back(); //加载 history 列表中的前一个 URL,等同于history.go(-1)。history.foward(); //加载 history 列表中的下一个 URL,等同于history.go(1)。history.pushState(state,title,url); //添加一条页面地址记录history.replaceState(state,title,url); //更新当前的历史地址记录 这里再额外说一句pushState方法和replaceState的区别，从网上找了一张图来表示 pushState()是在history栈中添加一个地址并同时跳往该地址，replaceState()是直接替换当前地址为新地址。 每当你使用pushState()或者replaceState()方法时，会触发popstate事件的回调 然后我们以这两个方法为基础，重新写一个Router的类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;a href=&quot;#/&quot;&gt;home&lt;/a&gt;&lt;a href=&quot;#/router1&quot;&gt;router1&lt;/a&gt;&lt;a href=&quot;#/router2&quot;&gt;router2&lt;/a&gt;&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;--------class Router&#123; constructor(router = &#123;&#125;)&#123; this.router = router; this.init(); &#125; route(path,cb)&#123; this.router[path] = cb || function () &#123; throw new Error(&quot;please give a callback&quot;); &#125;; &#125; refresh(state)&#123; let url = state.path || &quot;/&quot;; if(this.router[url])&#123; this.router[url](); &#125;else&#123; throw new Error(&quot;It&apos;s not register router&quot;); &#125; &#125; route(path,cb)&#123; this.router[path] = cb || function () &#123; throw new Error(&quot;please give a callback&quot;); &#125;; &#125; init()&#123; let _this = this; window.addEventListener(&quot;popstate&quot;,function (event) &#123; this.refresh(event.state || &#123;&#125;); &#125;.bind(this)) document.querySelectorAll(&quot;a&quot;).forEach(a =&gt; &#123; a.addEventListener(&quot;click&quot;,function (e) &#123; e.preventDefault(); let path = link.slice(1) || &quot;/&quot;; let link = a.getAttribute(&quot;href&quot;); _this.refresh(&#123;path : path&#125; || &#123;&#125;); if(e.target.getAttribute(&quot;type&quot;) === &apos;replace&apos;)&#123; window.history.replaceState(&#123;&apos;path&apos;:path&#125;,path,e.target.hre; &#125; else &#123; window.history.pushState(&#123;&apos;path&apos; : path&#125;,path,e.target.href); &#125; &#125;) &#125;,false); //首次进入路由 let path = window.location.hash.slice(1) || &apos;/&apos;; this.refresh(&#123;path : path&#125; || &#123;&#125;); &#125;&#125;function changeContent(text)&#123; document.getElementById(&apos;content&apos;).innerHTML = text;&#125; let router = new Router(&#123; &apos;/&apos;()&#123; changeContent(&quot;home&quot;); &#125;, &apos;/router1&apos;()&#123; changeContent(&quot;router1&quot;); &#125;, &apos;/router2&apos;()&#123; changeContent(&quot;router2&quot;); &#125;&#125;) router.route(&apos;/router3&apos;,function()&#123; changeContent(&apos;路由3&apos;); &#125;) 三、实现一个简单的vue-router版路由因为vue-router是基于Vue的插件，所以很多可以发现源码很多地方，都拥有很典型的Vue特色。 第一步跟着文件中的index.js入手，大致可以找出几个初始函数来createMatcher,createRouterMap,]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>技术文章</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[replace方法到模板编译]]></title>
    <url>%2F2017%2F12%2F29%2Fjs%E6%A8%A1%E6%9D%BF%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[本文章主要是自己用于熟悉正则的几个方法，并没有如何写正则表达式的内容，如果希望学习写正则匹配的，我也不太会(手动捂脸) 首先让我们先熟悉一个最常见的API——replace()方法 replace不会修改原字符串 语法和参数12str.replace(regexp|substr, newSubStr|function) 参数名称 参数含义 regexp 一个RegExp 对象或者字符串。该正则所匹配的内容会被第二个参数的返回值替换掉。 substr 一个要被 newSubStr 替换的字符串。其被视为一整个字符串，而不是一个正则表达式。仅仅是第一个匹配会被替换。 newSubStr 用于替换掉第一个参数在原字符串中的匹配部分的字符串。该字符串中可以内插一些特殊的变量名。参考下面的使用字符串作为参数。 function 一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。参考下面的指定一个函数作为参数。 先看一个最简单的例子1234let a = &quot;abcd1234&quot;.replace(&quot;1234&quot;,&quot;e&quot;); //将字符串&quot;1234&quot;替换为字符&quot;e&quot;let b = &quot;1234abcd1234&quot;.replace(/\d+/g,&quot;e&quot;); //将数字替换为字符&quot;e&quot;console.log(a); //abcde ,用字符串匹配没想到怎么全局替换，知道的可以告诉一下console.log(b); //eabcde 但是很多时候纯粹的替换字符的场景比较少，很多时候我们希望将获得到的值经过操作然后替换上去，所以replace()方法也很聪明的提供了回调函数。接下来我们来熟悉下回调函数的参数 先看语法1str.replace(regexp, function(match,p1,offset,string)&#123;&#125;) 再看参数含义 参数名 参数含义 match 匹配的子串，即字符串中那一些符合匹配规则的子字符串（可以理解成“abcd”中的是“bc”） p1 第一个匹配到的内容 offset 匹配到的子字符串在原字符串中索引。（比如，如果原字符串是“abcd”，匹配到的子字符串是“bc”，那么这个参数将是1） string 被匹配的原字符串。 其实如果大家之前有用过match这个API的话，就能发现他的形参全部是以match为基础进行实现的 这个时候再来一个简单版的小demo对着看，大家基本上就能明白了1234567891011&quot;strss&quot;.replace(/s+/g, function(match,offset,string)&#123; console.log(match) console.log(offset) console.log(string)&#125;);// s// 0// strss// ss// 3// strss 有没有一种ES5数组回调参数的既视感 不过回调函数提供的参数还赋予了更强大的功能，这里我们先暂时略过 发现还是避不过正则表达式匹配的内容 我们可以先在熟悉语法的情况下，一步一步从最基本的方法使用来认识这个方法 因为我们想在最终的替换中进一步转变匹配结果，所以我们必须使用一个函数。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>技术文章</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的圣诞老人]]></title>
    <url>%2F2017%2F12%2F25%2F%E6%88%91%E7%9A%84%E5%9C%A3%E8%AF%9E%E8%80%81%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[我不知道大家是什么时候知道圣诞节的，也不知道很多人会不会有和我一样的童年经历。 在我很小很小的时候，也许是幼儿园，也许是学前班，也许是记忆开始的时候，不知道从哪里听到了圣诞老人的传说。只要将一只空袜子放在床头，圣诞老人会在袜子里放上你最想要的礼物。 不知道刚听到这个传说的时候，自己是怎么样的心情，喜悦？迷惑？还是好奇。只记得自己小心翼翼的挑了一只最大的袜子，抚平了放在头边，然后带着期待的心情进入了梦乡。 现在已经想不起来自己第一次收到了什么礼物，一盒水彩笔？还是什么？ 但还能回忆出醒来之后睁大眼睛找袜子的我，拿着礼物在床上蹦蹦跳跳的我，告诉爸妈圣诞老人来了，最后拿起礼物飞奔出去炫耀的我。你知道吗，圣诞老人来我家送礼物啦！ 之后几年，自己依然和以前一样准备好了空袜子，也开始好奇圣诞老人到底是什么样子。只知道电视里的他是一个穿着红衣服，有的白胡子的老爷爷，他会从家里的烟囱爬进来，然后从大麻袋中挑出你最想要的礼物。 于是我不断在那一晚提醒着自己，不要睡着，要一直守着，要亲眼看看圣诞老人是什么样子的。可是孩子的好奇终究抵不过睡意，虽然第二天仍然收到了礼物，但还是没有看到老爷爷的样子。 只不过对孩子而言，只要有礼物就好了，圣诞老人到底是什么模样，他是不是从烟囱爬进来又有什么关系呢。 后来，直到有一年我再也没有在袜子边上看见礼物的时候，哭闹着打爸妈的时候，圣诞老人的故事在我身上就结束了。 懂事以后，自然知道了圣诞老人是假的。只是真的感谢我的圣诞老人，在我的童年里满足了一个爱幻想的小孩子，当别的小孩在说“圣诞老人就是你妈妈的时候”，“世界上没有圣诞老人”时，我仍然可以一口坚定，“世界上有圣诞老人”，“看，这就是圣诞老人给我的礼物”。感谢我的圣诞老人。 不知道为什么今晚会想写这一些的文字，只是真的很感谢我的爸爸妈妈。因为你们，帮助我在这个城市生活的远比很多人轻松，也是今年经历了太多的事情，我才明白，你们给我的帮助，远比我想象的还要更多。也许我永远无法当面说出“我爱你们”这些话，可是我会努力不让你们失望。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript 正则表达式迷你书》读后感]]></title>
    <url>%2F2017%2F11%2F19%2F%E3%80%8AJavaScript%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%B7%E4%BD%A0%E4%B9%A6%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[国庆时间看到作者出版了一本正则表达式的书，因为之前一直对模板好奇，于是就去作者的网盘里面下载了这一本书的pdf版观看。最近看完之后觉得作者写的很棒，弥补了自己很多正则的基础 知识。附上链接《JavaScript 正则表达式迷你书》问世了！。 文章主要记录了一下自己的学习心得 1. 复杂的正则表达式可以由几个简单的正则表达式组合而成记得之前每次写密码验证的时候，总希望一个正则表达式搞定全部的情况，看完书后觉得原来没有必要。 以密码验证为例出题：密码长度 6-12 位，由数字、小写字符和大写字母组成，但必须至少包括 2 种字符。大家可以想一下怎么实现。 书中一开始得出了一个非常复杂的正则表达式,但是其实后期维护修改未必简单，而且换一个同事来维护，刚开始理解也很辛苦。123456789101112131415&lt;!--复杂版正则表达式--&gt;let regex = /(?!^[0-9]&#123;6,12&#125;$)(?!^[a-z]&#123;6,12&#125;$)(?!^[A-Z]&#123;6,12&#125;$)^[0-9A-Za-z]&#123;6,12&#125;$/;&lt;!--简单易懂版正则表达式--&gt;let regex1 = /^[0-9A-Za-z]&#123;6,12&#125;$/; //6-12位的数字、小写字符和大写字母组成let regex2 = /^[0-9]&#123;6,12&#125;$/; //不包含数字（就是只包含大小写字母）let regex3 = /^[A-Z]&#123;6,12&#125;$/; //不包含大写字母（就是只包含数字和小写）let regex4 = /^[a-z]&#123;6,12&#125;$/; //不包含小写字母（就是只包含数字和大写）function checkPassword (string) &#123; if (!regex1.test(string)) return false; if (regex2.test(string)) return false; if (regex3.test(string)) return false; if (regex4.test(string)) return false; return true;&#125; 可以看到，第一种对于我这种刚开始实战不多的，颇有一点炫技的表现（也有可能是我太菜）。第二种一看，会舒服很多，高可读性和高可维护性。 我个人认为在团队合作中，第二种对于后期伙伴的维护应该是更佳的。 2. ?的各个含义在看书的时候，因为之前正则的基础很薄弱，看见书中频频出现的？用在不同地方实现不一样的效果，我是一脸懵逼，经常要上百度看一下？用在这里表示什么意思。这里小总结一下 2.1 本身符号“？”表达自身一个“？”字符，但是因为？在正则表达式中的作用太多了，所以当它需要表达自身的时候，需要进行一次转义1\? 2.2 表示匹配次数,这是常见的第一种用法，允许重复匹配的次数，0次或者1次。 例子123456789let regex1 = /\d*/;let str = &quot;12345&quot;;str.match(regex); //[&quot;12345&quot;, index: 0, input: &quot;12345&quot;]//======使用了？号======//let regex = /\d?/; //最大允许匹配一次数字let str = &quot;12345&quot;;str.match(regex); //[&quot;1&quot;, index: 0, input: &quot;1234&quot;] 2.3 表示懒惰匹配这是常见的第二种用法，因为正则表达式默认是贪婪匹配的，所以很多时候我们会在某组匹配字符后加一个问号表示非贪婪匹配 例子123456789let regex = /\d&#123;1,3&#125;/let str = &quot;12345&quot;;str.match(regex); //[&quot;123&quot;, index: 0, input: &quot;12345&quot;]//======添加了？号======//let regex = /\d&#123;1,3&#125;?/let str = &quot;12345&quot;;str.match(regex); //[&quot;1&quot;, index: 0, input: &quot;1234&quot;] 2.4 配合字符实现位置匹配书中讲到了 这么一句话 正则表达式是匹配模式，要么匹配字符，要么匹配位置。请记住这句话。 关于”位置”这个概念的理解推荐看书中的第二章 而当你匹配位置的时候，两个匹配位置的正则表达式就非常关键了。 (?=p)，其中 p 是一个子模式，即 p 前面的位置，或者说，该位置后面的字符要匹配 p。12let result = &quot;hello&quot;.replace(/(?=l)/g, &apos;#&apos;);console.log(result); // &quot;he#l#lo&quot; 而 (?!p) 就是 (?=p) 相反的意思，比如：12let result = &quot;hello&quot;.replace(/(?!l)/g, &apos;#&apos;);console.log(result); // &quot;#h#ell#o#&quot; 这两个用法在数字格式化的时候有非常大的用处。给大家出个题目吧，如何实现数字的千位分隔符表示。比如讲1234567转化为12,345,678。 大家思考一下 …. …. …. 答案12let regex = /(?!^)(?=(\d&#123;3&#125;)+$)/g;&quot;12345678&quot;.replace(regex1,&quot;,&quot;); // &quot;12,345,678&quot; 具体实现看不懂还是推荐去看原书，作者写的很好，我相信对大家帮助肯定也很大。 2.5 非捕获模式还有最后一种不怎么常见（可能是没怎么见过）的用法(?:),表示非捕获模式。我是这么理解的（不知道自己理解的对不对），就是当你遇到匹配的字符时，它并没有马上捕获匹配的内容，并且记录下拉，而是继续匹配下去作为为整体匹配服务。讲的不好，大家还是看例子实在吧（手动捂脸）。 例子12345let regex = /(?:a)(b)(c)/; &quot;abcabc&quot;.match(regex)//结果 [&quot;abc&quot;, &quot;b&quot;, &quot;c&quot;]// m[0] 是/(?:a)(b)(c)/匹配到的整个字符串，这里包括了a// m[1] 是捕获组1，即(b)匹配的子字符串substring or sub sequence// m[2] 是捕获组2，即(c)匹配到的 大家可以注意到第一个括号里面的a并没有被提取出来，但是整体匹配的字符时有a的。这就是我理解的非捕获模式，为整体存在的匹配。 3. 回溯的学习性能和效率始终是绕不开的一环，文中提到回溯造成原因我感觉主要是由2点造成的， 一是由于匹配默认是贪婪的 二是由于匹配有时候是懒惰的。(使用分支情况下) 3.1 贪婪匹配造成的回溯先说第一种情况，贪婪匹配造成的回溯，举个书中的例子123let str = &apos;&quot;abc&quot;de&apos;;let regex = /&quot;.*&quot;/;str.match(regex); // [&apos;&quot;abc&quot;&apos;, index: 0, input: &apos;&quot;abc&quot;de&apos;] 当用此正则表达式去匹配字符串的时候，发现最后无法完成整体匹配的时候，会不断回吐一个字符再次去尝试整体正确的匹配。大家可以结合下图理解。 书中最后讲到回溯是非常影响效率的，但是自己在写例子测试的时候，发现其实时间基本上没有任何差别，不知道是不是因为自己测试的正则比较简单，还是浏览器现在对于正则的优化做的比较好，总之没有达到书中说的到非常影响效率的程度。 效率对比例子12345678910111213141516171819function test()&#123; let str = &apos;&quot;abc&quot;dddddddddddddddddddddddddddddde&apos;; let regex = /&quot;.*&quot;/;&#125;;console.time()for(var i = 0;i&lt; 1000000000;i++)&#123;test()&#125;console.timeEnd()//default: 2321.663818359375ms//========修改为减少贪婪回溯的写法========//function test()&#123; let str = &apos;&quot;abc&quot;dddddddddddddddddddddddddddddde&apos;; let regex = /&quot;[^&quot;]]*&quot;/;&#125;;console.time()for(var i = 0;i&lt; 1000000000;i++)&#123;test()&#125;console.timeEnd()//default: 2327.2890625ms 对于这种回溯的解决方法来说： 方法1 ：写尽量正确的匹配。像上面例子中的修改版就是这种解决方法， 方法2 ：尽可能少的匹配。比如加个惰性量词“？”。(其实就是尽量减少贪婪匹配) 3.2懒惰匹配造成的回溯然而并不是所有回溯的情况都是由贪婪造成的。比如当我们在使用分支匹配的时候。 例子123let str = &apos;candy&apos;;let regex =/can|candy/;str.match(regex); //[&quot;can&quot;, index: 0, input: &quot;candy&quot;] 当我们用/can|candy/去匹配字符串 “candy”，得到的结果是 “can”，因为分支会一个一个尝试，如果前面的满足了，后面就不会再试验了。但是如果我们的目标字符串是“candy”的时候，那怎么办呢。 例子123let str = &apos;candy&apos;;let regex = /^(?:can|candy)$/;str.match(regex); //[&quot;candy&quot;, index: 0, input: &quot;candy&quot;] 大家可以先看图理解一下懒惰造成的回溯 4. 跟正则有关几个正则方法字符串对象和正则对象提供了很多跟正则有关的基础方法，很多方法都都有很好的使用场景。 4.1 RegExp#test比如我在表单验证的场景里，用户每次输入值我需要进行判断用户是否输入正确，我可是使用regex.test()方法来确定是否给用户提示 只允许输入数字123456&lt;input onkeyup=&quot;test(this.value)&quot; /&gt;function test(value)&#123; let regex = /[^\d]/g; if(regex.test(value))console.log(&quot;请输入数字&quot;)&#125; 4.2 String#replace这个replace方法用处实在是太大了，已经到了可以单开一篇的地步了，大家可以前往这里去看MDN上replace的文档，这里就不详细介绍了。这里写个简单的例子 最简单的模板编译12345678910let str = &apos;我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;&apos;;let obj = &#123; name:&apos;姓名&apos;, age:18, sex: &apos;男&apos; &#125;let strEnd = str.replace(/\&#123;\&#123;(.+?)\&#125;\&#125;/g,function (match, m1) &#123; return obj(m1)&#125;)// &quot;我是姓名，年龄18，性别undefined&quot; 4.3 String#search这个方法感觉和indexOf效率有一些相似，都是寻找符合匹配的下标。不过indexOf方法是为字符串使用的，而search是为正则表达式实现的123let str = &apos;abc123456&apos;;let regex = /\d/;console.log(str.search(regex)); // 3 4.3 String#split字符串的split方法同样支持正则表达式进行切割123var regex = /,/;var string = &quot;html,css,javascript&quot;;console.log( string.split(regex) ); 4.4 String#match这个方法更多是为了提取匹配内容而存在的。当你的正则表达式里面有小括号（）的存在时，match方法可以帮你提取出字符串中符合括号正则的表达式。1234var regex = /^(\d&#123;4&#125;)\D(\d&#123;2&#125;)\D(\d&#123;2&#125;)$/;var string = &quot;2017-06-26&quot;;console.log( string.match(regex) );// [&quot;2017-06-26&quot;, &quot;2017&quot;, &quot;06&quot;, &quot;26&quot;, index: 0, input: &quot;2017-06-26&quot;]]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>books</tag>
        <tag>技术文章</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法图解读后感]]></title>
    <url>%2F2017%2F10%2F29%2F%E3%80%8A%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[算法算法，一个这两年被人念叨最多的词汇，但很多时候身为一个前端人员完全感受不到其所在，所以一直对此也很是懵逼。这段时间也是无聊，于是看了一本算法图解的书，还是很能感受到其中的一些魅力所在的额 先开坑 一二分查找算法,是本书的第一个算法，用于有序数据的快速查找。 二链表相对于数组的优势 当插入数据较多而读取数据较少时， 1 数组 链表 插入 O(n),需要从第一个开始查找到最后一个才能插入 O(1)随便扔一个地方 读取 O(1)直接知道数据位置在哪里 O(n)需要知道前面的才能知道后面的 删除 O(n)遍历所有的一个个开始删除 O(1)直接修改每个项所代表的索引 三 快速查找排序算法快速查找排序算法：最常见的排序算法，举例描述：先找出一个数组中最小的，推出到新数组中，然后来n次遍历，得出由小到大的新数组。时间复杂度为O(n2); 四递归调用主要讲解了基本的栈和递归调用，最后讲到的高级递归主题尾递归需要看一下 五]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>技术文章</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中数组的原生方法]]></title>
    <url>%2F2017%2F09%2F03%2FJavascripts%E6%95%B0%E7%BB%84%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[数组应该是我们在写程序中应用到最多的数据结构了，相比于无序的对象，有序的数组帮我们在处理数据时，实在是帮了太多的忙了。今天刚好看到一篇Array.include的文章，忽然发现经过几个ES3,ES5,ES6,ES7几个版本的更迭，发现在代码中用到了好多数组的方法，所以准备全部列出来，也是给自己加深印象 1 ES3中的数组方法 ES3兼容现在所有主流浏览器 ES3中的方法毫无疑问大家已经烂熟在心了，不过中间有些细节可以回顾加深一下记忆，比如是否修改原数组返回新数组，执行方法之后的返回值是什么，某些参数的意义是否搞混等等。熟悉的的可以直接快速浏览或者跳过。 1.1 join()方法Array.join()方法是将一个数组里面的所有元素转换成字符串，然后再将他们连接起来返回一个新数组。可以传入一个可选的字符串来分隔结果字符串中的所有元素。如果没有指定分隔字符串，就默认使用逗号分隔。123let a = [1,2,3,4,5,6,7];let b = a.join(); // b = &quot;1,2,3,4,5,6,7&quot;;let c = a.a.join(&quot; &quot;); // b = &quot;1 2 3 4 5 6 7&quot;; 方法Array.join()恰好与String.split()相反，后者是通过将一个字符串分隔成几个元素来创建数组 1.2 reverse()方法Array.reverse()方法将颠倒数组中元素的顺序并返回一个颠倒后的数组。它在原数组上执行这一操作，所以说并不是创建了一个新数组，而是在已存在的数组中对元素进行重排。12let a = [1,2,3,4,5,6,7];a.reverse(); // a = [7,6,5,4,3,2,1] 1.3 sort()方法Array.sort()是在原数组上进行排序,返回排序后的数组。如果调用方法时不传入参数，那么它将按照字母顺序对数组元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。 如果数组中有未定义的元素，这些元素将放在数组的末尾123let a = [1,12,23,14,,undefined,null,NaN,56,6,7,&quot;a&quot;,&#123;&#125;,[]];a.sort(); //[[], 1, 12, 14, 23, 56, 6, 7, &quot;NaN&quot;, &#123;&#125;, &quot;a&quot;, null,undefined,undefined × 1] //返回的NaN已经是一个字符串，说明在比较过程中将其转化成了字符串进行比较 仔细看可以发现，上面顺序并没有按照数字大小进行排序。如果想按照其他标准进行排序，就需要提供比较函数。该函数比较前后两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下： 若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。 若 a 等于 b，则返回 0。 若 a 大于 b，在排序后的数组中 a 应该出现在 b 之后，则返回一个大于 0 的值。12let a = [1,12,23,14,,undefined,null,NaN,56,6,7,&quot;a&quot;,&#123;&#125;,[]];a.sort((a,b) =&gt; &#123;return a - b&#125;); //[null, Array(0), NaN, Object, 1, 6, 7, 12, 14, 23, 56, &quot;a&quot;,undefined, undefined × 1] 1.4 concat()方法Array.concat() 方法用于连接两个或多个参数（数组，字符串等），该方法不会改变现有的数组，而会返回连接多个参数的一个新数组。如果传入的参数是数组，那么它将被展开，将元素添加到返回的数组中。但要注意，concat并不能递归的展开一个元素为数组的参数。 12let a = [1,2,3];let b = a.concat(4,5,[6,7,[9,10]]); // b = [1,2,3,4,5,6,7,[9,10]]]; 1.5 slice()方法Array.slice() 方法可从已有的数组中返回指定的一个片段(slice)，或者说是子数组。它是从原数组中截取了一个片段，并返回到了一个新数组。 Array.slice(a,b) 它有两个参数a,b 参数 描述 a 必选。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。 b 可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。 12345let a = [1,2,3,4,5,7,8];let b = a.slice(3); // [4, 5, 7, 8]let c = a.slice(3,5); // [4, 5]let d = a.slice(-5,-2); // [3, 4, 5]let d = a.slice(2,1); // [] 请注意，该方法并不会修改数组，而是返回一个新的子数组。如果想删除数组中的一段元素，应该使用下面这个方法 Array.splice()。 1.6 splice()方法Array.splice() 方法从数组中添加/删除元素，然后返回被删除的元素。它在原数组上修改数组，并不像slice和concat那样创建新数组。注意，虽然splice和slice名字非常相似，但是执行的却是完全不同的操作。 参数 描述 index 必选,整数。规定添加/删除项目的位置，使用负数可从数组结尾处倒着寻找位置。 howmany 可选,整数。要删除的元素数量。如果设置为 0，则不会删除元素。如果没有选择，则默认从index开始到数组结束的所有元素 item1, …, itemX 可选。向数组添加新的元素。 12345678let a = [1,2,3,4,5,7,8];let b = a.splice(3); // a = [1,2,3] b = [4, 5, 7, 8]-----------------------------------------------------------let c = [1,2,3,4,5,7,8]; let d = c.splice(3,5); // c = [1,2] d = [3,4,5,7,8]-----------------------------------------------------------let e = [1,2,3,4,5,7,8]; let f = e.splice(3,2,111,222,[1,2]); // e = [1, 2, 3, 111, 222,[1,2], 7, 8] f = [4,5] 大家要记住slice()和splice()两个方法第二个参数代表的意义是不一样的。虽然这很基础，可是有时候还是会弄混。 1.7 push()和pop()方法Array.push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。 Array.pop()方法用于删除并返回数组的最后一个元素。如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值。123let a = [1,2,3,4,5];let b = a.pop(); //a = [1,2,3,4] b = 5let c = a.push(1,3,5); // a = [1,2,3,4,1,3,5] c = 7 上面两个方法都是直接对原数组进行操作。通过上面两个方法可以实现一个先进后出的栈。 1.8 unshift和shift()方法unshift，shift()的方法行为和push()，pop()非常相似，只不过他们是对数组的头部元素进行插入和删除。 Array.unshift() 方法可向数组的头部添加一个或多个元素，并返回新的长度。 Array.shift()方法用于删除并返回数组的第一个元素。如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值。123let a = [1,2,3,4,5];let b = a.shift(); //a = [2,3,4,5] b = 1let c = a.unshift(1,3,5); // a = [1,3,5,2,3,45] c = 7 1.9 toString()和toLocaleString()方法和所有javascript的对象一样，数组也有toString()方法，这个方法可以将数组的每一个元素转化成字符串(如果必要的话，就调用元素的toString()方法)，然后输出字符串的列表，字符串之间用逗号隔开。(用我的话来理解，其实就是遍历数组元素调用每个元素自身的toString()方法，然后用逗号连接) toString()的返回值和没有参数的join()方法返回的字符串相同12let a = let e = [1,undefined,null,Boolean,&#123;&#125;,[],function()&#123;console.log(1);&#125;];let b = a.toString(); // b = &quot;1,,,function Boolean() &#123; [native code] &#125;,[object Object],,function ()&#123;console.log(1);&#125;&quot; 注意，输出的结果中，返回的数组值周围没有括号。 toLocaleString方法是toString()方法的本地化版本。它是使用地区特定的分隔符把生成的字符串连接起来，形成一个字符串。 虽然是两个方法，但是一般元素两个方法的输出结果却基本是一样的，去网上找了相关文章，发现只有两种情况比较有区分，一个是时间，一个是4位数字以上的数字,举例如下1234567let a = 1111;let b = a.toLocaleString(); // b = &quot;1,111&quot;let c = a.toString(); // c = &quot;1111&quot;;-------------------------------------------------------let date = new Date();let d = date.toString(); // d = &quot;Sun Sep 03 2017 21:52:18 GMT+0800 (中国标准时间)&quot;let e = date.toLocaleString(); //e = &quot;2017/9/3 下午9:52:18&quot; 好吧，这个api和数组关系不大。。。主要还是和数组中元素自身有关。啊哈哈，尴尬。 1.10 valueOf()Array.valueOf()方法在日常中用的比较少，该方法继承与Object。javascript中许多内置对象都针对自身重写了该方法，数组Array.valueOf()直接返回自身。123let a = [1,&quot;1&quot;,&#123;&#125;,[]];let b = a.valueOf();a === b; // true 好啦，关于ES3的方法就不详细描述了，我相信大家基本上都已经完全是烂熟于心的那种，唯一可能需要加强记忆的就是一些参数含义，返回数据这些了。 2 ES5中的数组方法 ES5中的数组方法在各大浏览器的兼容性 Opera 11+ Firefox 3.6+ Safari 5+ Chrome 8+ Internet Explorer 9+ 2.Array在ES5新增的方法中接受两个参数，第一个参数都是function类型，必选，默认有传参，这些参数分别是： currentValue : 数组当前项的值 index : 数组当前项的索引 array : 数组对象本身 第二个参数是当执行回调函数时指向的this(参考对象)，不提供默认为window，严格模式下为undefined。 以forEach举例 语法12345array.forEach(callback, thisArg)array.forEach(callback(currentValue, index, array)&#123; //do something&#125;, thisArg) 例子：12345678910111213141516//demo,注意this指向//我这个demo没有用箭头函数来测试let a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];a.forEach(function(currentValue, index, array)&#123; this.info(currentValue, index, array);&#125;,&#123;info:function(value,index,array)&#123; console.log(`当前值$&#123;value&#125;，下标$&#123;index&#125;,数组$&#123;array&#125;`)&#125;&#125;);function info(value,index,array)&#123; console.log(`外放方法 ： 当前值$&#123;value&#125;，下标$&#123;index&#125;,数组$&#123;array&#125;`)&#125;&#125;// 当前值a,下标0,数组a,b,c// 当前值b,下标1,数组a,b,c// 当前值c,下标2,数组a,b,c 3.ES5中的所有关于遍历的方法按升序为数组中含有效值的每一项执行一次callback函数，那些已删除（使用delete方法等情况）或者未初始化的项将被跳过（但不包括那些值为 undefined 的项）（例如在稀疏数组上）。 例子：数组哪些项被跳过了123456789101112131415function logArrayElements(element, index, array) &#123; console.log(`a[$&#123;index&#125;] = $&#123;element&#125;`);&#125;let xxx; //定义未赋值let a = [1,2,&quot;&quot;, ,undefined,xxx,3];delete a[1]; // 移除 2a.forEach(logArrayElements);// a[0] = 1// 注意索引1被跳过了，因为在数组的这个位置没有项 被删除了// a[2] = &quot;&quot;// 注意索引3被跳过了，因为在数组的这个位置没有项,可以理解成没有被初始化// a[4] = undefined// a[5] = undefined// a[6] = 3 好了，上面3点基本上是ES5中所有方法的共性，下面就不重复述说了。开始正文解析每个方法的不同了 2.1 forEach()Array.forEach() 为每个数组元素执行callback函数；不像map() 或者reduce() ，它总是返回 undefined值，并且不可链式调用。典型用例是在一个链的最后执行副作用。 注意： 没有办法中止或者跳出 forEach 循环，除了抛出一个异常。如果你需要跳出函数，推荐使用Array.some。如果可以，新方法 find() 或者findIndex() 也可被用于真值测试的提早终止。 如果数组在迭代时被修改了 下面的例子输出”one”, “two”, “three”。当到达包含值”two”的项时，整个数组添加了一个项在第一位，这导致所有的元素下移一个位置。此时在下次执行回调中，因为元素 “two”符合条件，结果一直增加元素，直到遍历次数完毕。forEach()不会在迭代之前创建数组的副本。1234567891011let a = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;];let b = a.forEach((value,index,arr) =&gt; &#123; if (value === &quot;two&quot;) &#123; a.unshift(&quot;zero&quot;); &#125; return &quot;new&quot; + value&#125;);// one,0,[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]// two,1,[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]// two,2,[&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;]// two,3,[&quot;zero&quot;,&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;] 看完例子可以发现，使用 forEach 方法处理数组时，数组元素的范围是在callback方法第一次调用之前就已经确定了。在 forEach 方法执行的过程中：原数组中新增加的元素将不会被 callback 访问到；若已经存在的元素被改变或删除了，则它们的传递到 callback 的值是 forEach 方法遍历到它们的那一个索引时的值。 2.2 map()Array.map 方法会给原数组中的每个元素都按顺序调用一次callback函数。callback每次执行后的返回值（没有指定返回值则返回undefined）组合起来形成一个新数组。 例子：返回每个元素的平方根的数组12345let a = [1,4,9];let b = a.map((value) =&gt; &#123; return Math.sqrt(value); //如果没有return，则默认返回undefined&#125;);// b= [1,2,3] 2.3 filter()Array.filter()为数组中的每个元素调用一次 callback 函数，并利用所有使得 callback 返回 true 或 等价于 true 的值 的元素创建一个新数组。那些没有通过 callback 测试的元素会被跳过，不会被包含在新数组中 例子：数组去重12345let a = [1,2,3,4,32,6,79,0,1,1,8];let b = a.filter((value,index,arr) =&gt; &#123; return arr.indexOf(value) === index;&#125;);// b = [1, 2, 3, 4, 32, 6, 79, 0, 8] 2.4 some()Array.some 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个“真值”（即可转换为布尔值 true 的值）。如果找到了这样一个值，some 将会立即返回 true。否则，some 返回 false。callback 只会在那些”有值“的索引上被调用，不会在那些被删除或从来未被赋值的索引上调用。 例子：查看数组内是否含有大于0的元素12345let a = [-1,4,9];let b = a.some((value) =&gt; &#123; return value &gt; 0; //如果没有return，则默认返回undefined，将无法告诉some判断&#125;);// b = true some方法可以理解成拥有跳出功能的forEach()函数，可以用在在一些需要中断函数的地方 2.5 every() Array.every() 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个使 callback 返回 false（表示可转换为布尔值 false 的值）的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。callback 只会为那些已经被赋值的索引调用。不会为那些被删除或从来没被赋值的索引调用。 例子：检测所有数组元素的大小，是否都大于012345let a = [-1,4,9];let b = a.every((value) =&gt; &#123; return value &gt; 0; //如果没有return，则默认返回undefined&#125;);// b = false 2.6 indexOf()Array.indexOf()使用严格相等（strict equality，即===）进行判断searchElement与数组中包含的元素之间的关系。 Array.indexOf()提供了两个参数，第一个searchElement代表要查询的元素，第二个代表fromIndex表示从哪个下标开始查找，默认为0。 语法12arr.indexOf(searchElement)arr.indexOf(searchElement, fromIndex = 0) Array.indexOf()会返回首个被找到的元素在数组中的索引位置; 若没有找到则返回 -1 例子：123456let array = [2, 5, 9];array.indexOf(2); // 0array.indexOf(7); // -1array.indexOf(9, 2); // 2array.indexOf(2, -1); // -1array.indexOf(2, -3); // 0 2.7 lastIndexOf()Array.lastIndexOf()就不细说了，其实从名字大家也可以看出来，indexOf是正向顺序查找，lastIndexOf是反向从尾部开始查找，但是返回的索引下标仍然是正向的顺序索引。语法1arr.lastIndexOf(searchElement, fromIndex = arr.length - 1) 需要注意的是，只是查找的方向相反，fromIndex和返回的索引都是正向顺序的，千万不要搞混了（感觉我这么一说，大家可能搞混了，捂脸）。 例子：各种情况下的的indexOf1234567var array = [2, 5, 9, 2];var index = array.lastIndexOf(2); // index = 3index = array.lastIndexOf(7); // index = -1index = array.lastIndexOf(2, 3); // index = 3index = array.lastIndexOf(2, 2); // index = 0index = array.lastIndexOf(2, -2); // index = 0index = array.lastIndexOf(2, -1); // index = 3 2.8 reduce()Array.reduce() 为数组中的每一个元素依次执行回调函数,最后返回一个函数累计处理的结果。 语法1array.reduce(function(accumulator, currentValue, currentIndex, array), initialValue) reduce的回调函数中的参数与前面的不同，多了第一个参数，是上一次的返回值 accumulator : 上一次调用回调返回的值，或者是提供的初始值（initialValue） currentValue : 数组当前项的值 currentIndex : 数据当前项的索引。第一次遍历时，如果提供了 initialValue ，从0开始；否则从1开始 array : 调用 reduce 的数组 initialValue : 可选项，其值用于第一次调用 callback 的第一个参数。如果没有设置初始值，则将数组中的第一个元素作为初始值。空数组调用reduce时没有设置初始值将会报错。 例子：数组求和1234let sum = [0, 1, 2, 3].reduce(function (o,n) &#123; return o + n;&#125;);// sum = 6 对了，当回调函数第一次执行时，accumulator 和 currentValue 的取值有两种情况： 调用 reduce 时提供initialValue，accumulator 取值为 initialValue ，currentValue 取数组中的第一个值； 没有提供 initialValue ，accumulator 取数组中的第一个值，currentValue 取数组中的第二个值。 例子：reduce数组去重12345678[1,2,3,4,5,6,78,4,3,2,21,1].reduce(function(accumulator,currentValue)&#123; if(accumulator.indexOf(currentValue) &gt; -1)&#123; return accumulator; &#125;else&#123; accumulator.push(currentValue); return accumulator; &#125;&#125;,[]) 注意 ：如果数组为空并且没有提供initialValue， 会抛出TypeError 。如果数组仅有一个元素并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。 2.9 reduceRight()方法Array.reduceRight() 为数组中的每一个元素依次执行回调函数，方向相反，从右到左,最后返回一个函数累计处理的结果。 因为这个方法和reduce方法基本是一模一样的，除了方法相反，所以就不详细的再写一遍了 2.10 isArray()方法之所以将这个方法放在最后，是因为这个方法和前面的不太一致，是用于确定传递的值是否是一个 Array,使用方法也很简单 例子12let a = Array.isArray([1,2,3]); //truelet b = Array.isArray(document.getElementsByTagName(&quot;body&quot;)); //类数组也为false 不过感觉除非是临时判断，不然一般也不会用这个方法去判断，一般还是下面这种万金油型的吧。 1Object.prototype.toString.call([]).slice(8, -1) === &quot;Array&quot;;//true 好啦，关于ES5的方法基本上就讲到这里了，感觉自己在深入去看了一些文章之后，还是有一些额外的收获的。比如对reduce这个平时不常用的方法了解更加深刻了，感觉之前很多遍历收集数据的场景其实用reduce更加方便。 3 ES6中的数组方法 不同于es5主要以遍历方法为主，es6的方法是各式各样的，不过必须要说一句，在性能上，es6的效率基本上是最低的。 3.1 …方法——concat方法的增强英文名字叫做Spread syntax，中文名字叫做扩展运算符。 3.2 of()方法Array.of()方法可以将传入参数以顺序的方式返回成一个新数组的元素。1let a = Array.of(1, 2, 3); // a = [1, 2, 3] 其实，刚看到这个api和他的用途，还是比较懵逼的，因为看上去这个方法就是直接将传入的参数变成一个数组之外，就没有任何区别了，那么我为什么不直接用以前的写法去实现类似的效果呢，比如 let ＝ [1,2,3];而且看上去也更加直接。然后我去翻了下最新的ECMAScript草案，其中有这么一句话 The of function is an intentionally generic factory method; it does not require that its this value be the Array constructor. Therefore it can be transferred to or inherited by other constructors that may be called with a single numeric argument. 自己理解了一下，其实大概意思就是说为了弥补Array构造函数传入单个函数的不足，所以出了一个of这个更加通用的方法，举个例子12let a = new Array(1);//a = [undefined × 1]let b = new Array(1,2);// b = [1,2] 大家可以注意到传入一个参数和传入两个参数的结果，完全是不一样的，这就很尴尬了。而为了避免这种尴尬，es6则出了一种通用的of方法，不管你传入了几个参数，都是一种相同类型的输出结果。 不过我好奇的是，如果只传入几个参数，为什么不直接let a = [1,2,3];效率和直观性也更加的高。如果要创建一个长度的数组，我肯定还是选let a = new Array(10000),这种形式，实在没有感觉到Array.of的实用场景，希望大家可以给我点指导。 3.2 from()方法Array.from()方法从一个类似数组（拥有一个 length 属性和若干索引属性的任意对象）或可迭代的对象(String, Array, Map, Set和 Generator)中创建一个新的数组实例。 我们先查看Array.from()的语法 语法1Array.from(arrayLike, mapFn, thisArg) 从语法中，我们可以看出Array.from()最基本的功能是将一个类数组的对象转化成数组，然后通过第二个和第三个参数可以对转化成功后的数组再次执行一次遍历数据map方法,也就是Array.from(obj).map(mapFn, thisArg)。 对了额外说一句，这个方法的性能很差，和直接的for循环的性能对比了一下，差了百倍不止。 例子 :将一串数字字符串转化为数组12let a = Array.from(&quot;242365463432&quot;,(value) =&gt; return value * 2);//a = [4, 8, 4, 6, 12, 10, 8, 12, 6, 8, 6, 4] 3.4 copyWithin()方法Array.copyWithin方法，在当前数组内部，将指定位置的成员浅复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 这个方法有点复杂，光看描述可能大家未必能轻易理解，大家可以先看下语法，再看demo配合理解，而且自己没有想到这个方法合适的应用场景。网上也没又看到相关使用场景。但是讲道理，这个方法设计出来，肯定是经过深思熟虑的，如果大家有想到，欢迎评论给我，谢谢。 语法12arr.copyWithin(target, start, end)//arr.copyWithin(目标索引, 源开始索引, 结束源索引) 例子12345678// 将3号位复制到0号位[1, 2, 3, 4, 5].copyWithin(0, 3, 4); // [4, 2, 3, 4, 5]// 将2号位复制到0号位[1, 2, 3, 4, 5].copyWithin(0, 2, 5); //[3, 4, 5, 4, 5] // 将3号位复制到0号位[1, 2, 3, 4, 5].copyWithin(4, 1, 4); //[1, 2, 3, 4, 2] 第一个是常规的例子，大家可以对比看第二个可以发现，这个方法是先浅复制了数组一部分暂时存储起来，然后再从目标索引处开始一个个覆盖后面的元素，直到这段复制的数组片段全部粘贴完。 再看第三个例子，可以发现当复制的数据片段从目标索引开始粘贴时，如果超过了长度，它将停止粘贴，这说明它不会改变数据的 length，但是会改变数据本身的内容。 Array.copyWithin可以理解成复制以及粘贴序列这两者是为一体的操作;即使复制和粘贴区域重叠，粘贴的序列也会有拷贝来的值。 3.5 find() 和 findIndex()方法Array.find()方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。 Array.findIndex() 方法返回数组中满足提供的测试函数的第一个元素的值的索引。否则返回 -1。 这两个方法其实使用非常相似，使用场景有点像ES5中Array.some，都是在找到第一个满足条件的时候，跳出循环，区别的是，三种返回的值完全不一样，我想这也许是为什么要在ES6中增加这两个API的原因吧，可以理解成是数组的方法的补足。 例子：三个方法各自的返回值 12345678 let a = [1,2,3,4,5].find((item)=&gt;&#123;return item &gt; 3&#125;); // a = 4 返回第一个符合结果的值let b = [1,2,3,4,5].findIndex((item)=&gt;&#123;return item &gt; 3&#125;); // b = 3 返回第一个符合结果的下标let c = [1,2,3,4,5].some((item)=&gt;&#123;return item &gt; 3&#125;); // c = true 返回是否有符合条件的Boolean值-----------------不满足条件-------------------- let a = [1,2,3,4,5].find((item)=&gt;&#123;return item &gt; 6&#125;); // a = undefinedlet b = [1,2,3,4,5].findIndex((item)=&gt;&#123;return item &gt; 6&#125;); // b = -1let c = [1,2,3,4,5].some((item)=&gt;&#123;return item &gt; 6&#125;); // c = false 注意：find()和findIndex()方法无法判断NaN,可以说是内部用 ===判断，不同于ES7中的include方法。不过这个判断方式是另外一个话题，不在本文详述了，感兴趣的同学可以去查一下。 其实还可以发现，Array.find() 方法只是返回第一个符合条件的元素，它的增强版是es5中Array.filter()方法，返回所有符合条件的元素到一个新数组中。可以说是当用find方法时考虑跟多的是跳出吧。 我感觉这4个方法配合相应的回调函数基本上可以完全覆盖大多数需要数组判断的场景了，大家觉得呢？ 3.5 fill方法Array.fill()方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素,返回原数组 这个方法的使用也非常简单，大家基本上看个语法和demo就能懂了。需要注意的是，这个方法是返回数组本身，还有一点就是，类数组不能调用这个方法，刚刚自己去改了MDN上面的文档。 语法123arr.fill(value) arr.fill(value, startIndex) arr.fill(value, startIndex, endIndex) 例子1234let a = new Array(10);a.fill(1); // a = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1];let b = [1,2,34,5,6,7,8].fill(3,4); //b = [1, 2, 34, 5, 3, 3, 3];let c = [1,2,34,5,6,7,8].fill(3,2,5); // c = [1, 2, 3, 3, 3, 7, 8]; 个人感觉这个方法初始化数组挺有用的，自己一周每次测试数据时，只要new Array().fill(1);,比以前遍历直观方便多了 3.6 entries()，keys(),values()方法Array.entries()将数组转化成一个中包含每个索引的键/值对的Array Iterator对象 Array.keys()将数组转化成一个中包含每个索引的键的Array Iterator对象 Array.values()将数组转化成一个中包含每个索引的值的Array Iterator对象。 Array.values()方法chrome浏览器并不支持， 之所以将这三个方法放在一起是有原因的额，大家可以看这三个方法其实都是一个数组转化为一种新的数据类型——返回新的Array Iterator对象，唯一区别的是转化之后的元素不一样。跟他们的名字一样，entries()方法转化为全部的键值对，key()方法转化为键，value()保留值。 例子：观察各个迭代器遍历输出的东西 Array.entries()12345let a = [1,2,3].entries();for(let i of a)&#123;console.log(i);&#125;//[0, 1]//[1, 2]//[2, 3] Array.keys()12345let b = [1,2,3].keys();for(let i of b)&#123;console.log(i);&#125;//0//1//2 Array.values()12345let c = [1,2,3].values();for(let i of c)&#123;console.log(i);&#125;//1//2//3 关于迭代器这个东西，自己说不上什么，因为自己没有亲自用过，如果大家有什么见解课可以评论给我，我来补充和学习一下 4 ES7中的数组方法4.1 includes()方法Array.includes方法返回一个布尔值，表示某个数组是否包含给定的值，如果包含，则返回true，否则返回false,与字符串的includes方法类似。 这个方法大家可以看作是ES5中Array.indexOf的语义增强版，“includes”这个是否包含的意思，直接返回Boolean值，比起原来的indexOf是否大于-1,显得更加直观,我就是判断有没有包含哪个值 语法，使用方法和indexof一模一样12arr.includes(searchElement)arr.includes(searchElement, fromIndex) 例子123456let array = [2, 5, 9];array.includes(2); // truearray.includes(7); // falsearray.includes(9, 2); // truearray.includes(2, -1); // falsearray.includes(2, -3); // true 方法还真是tmd多啊，感觉基本上应该是更新完了，前后两星期花了我4天时间吧，还是挺累的。不过收货还是很多，比如知道了ES5的方法基本上都有第二个this指向的参数，重新认识了reduce方法，感觉自己之前很多场景用reduce更好，重新熟悉了一些ES6的方法可以试用有些场景 如果能看到最后的，感觉你也是够累的，哈哈哈。既然这么累，点颗星吧]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>技术文章</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解jquery的深拷贝]]></title>
    <url>%2F2017%2F08%2F24%2F%E7%90%86%E8%A7%A3jquery%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[好像自从使用框架之后，对jquery的依赖越来越低了，其好像已经慢慢作为一个工具库的存在了。新项目商量之下，为了减小文件大小，干脆直接不用jquer2，对于一些需要的工具函数直接从jquery提取到一个自己写的工具文件tool.js中。在提取的过程中，也慢慢理解了jquery一些工具函数的源码 深拷贝和浅拷贝的使用场景不同，并没有好坏之分，像对一些基本数据类型，直接可以使用浅拷贝对处理数据。但是对于基本引用类型如嵌套对象，数组（包含着对象的数组），那么就需要使用到深拷贝了。 不想看前面深浅拷贝对比的，可以直接拉到第二章看jquery源码实现 1.浅拷贝解析原生js也有一些提供拷贝的函数，比如数组的Array.slice(0),Array.concat()，对象的Object.create(),Object.assign()等等，但是都是浅拷贝，遇到二维数组，嵌套对象就通通失败了（以前不懂的时候，真的被坑的不要不要的啊）。 比如下面这个例子，都是在只有基本数据类型的情况下，使用浅拷贝就可以了。123456789101112131415let arr = [1,2,34,5,67,8,9];let cloneArr = arr.slice(4);console.log(cloneArr); // [67, 8, 9]cloneArr[0] = 100; // 修改cloneArrconsole.log(arr); // [1,2,34,5,67,8,9],修改cloneArr不影响原数组arr----------------let obj = &#123;a : 1,b : 2,c : 3,&#125;;let cloneObj = Object.assign(&#123;&#125;,obj);// 将拷贝的属性值拷贝到目标对象，然后返回目标对象console.log(cloneObj); // cloneObj = &#123;a : 1,b : 2,c : 3,&#125;;cloneObj.a = 444; //修改对象console.log(obj); // obj = &#123;a : 1,b : 2,c : 3,&#125;; 修改拷贝对象不影响源对象 但是如果以上例子将基本数据类型换成引用类型Object和Array呢？ 123456789101112131415let arr = [1,2,&#123;a : 3&#125;,&#123;b : 4&#125;,5];let cloneArr = arr.slice(2);console.log(cloneArr); // [&#123;a : 3&#125;,&#123;b : 4&#125;,5];cloneArr[0].a = 100; // 修改cloneArrconsole.log(arr); // [1,2,&#123;a : 100&#125;,&#123;b : 4&#125;,5],修改cloneArr影响原数组arr----------------let obj = &#123;a : &#123;aa : 1&#125;,b : &#123;bb : 2&#125;,c : 3,&#125;;let cloneObj = Object.assign(&#123;&#125;,obj);// 将拷贝的属性值拷贝到目标对象，然后返回目标对象console.log(cloneObj); // cloneObj = &#123;a : &#123;aa : 1&#125;,b : &#123;bb : 2&#125;,c : 3,&#125;;cloneObj.a.aa = 100; //修改对象console.log(obj); // obj = &#123;a : &#123;aa : 100&#125;,b : &#123;bb : 2&#125;,c : 3,&#125;; 修改拷贝对象影响到了源对象 为什么会这样子，原因其实也不复杂。js内存分为栈内存和堆内存。所有的基本数据类型都是存储在栈内存中，而引用类型则是存储在堆内存中，提供了一个地址放在了栈内存中。当我们要获取引用类型的值时，先从栈内存获得地址，再根据地址去堆内存中获得值。因此也叫按引用访问。 (去网上浅拷贝了一张图片，因为拷贝了一个图片地址) 而我们上面例子中，每个数组和对象每个属性存储的引用类型obj其实是个地址，我们只是简单的拷贝了属性值，其实就是拷贝了一个地址。所以我们在新对象里进行修改时，由于是通过同一个地址修改了值。因为和原对象共用了一个地址，所以自然就修改了原对象的值了。 2.深拷贝解析前面解析了浅拷贝。因为我们项目对大型数据处理占据了大头，其中不可避免的会经常用到深拷贝这块。那么深拷贝是怎么实现的。 其实也很简单，就是根据地址找到你堆内存中的值，不断递归深入拷贝下去，直到为基本数据类型为止，接下去就贴上深拷贝代码。 在讲jquey前，还有一个很暴力的方式JSON.parse()和JSON.stringify();缺点是 数据不能包含函数。 如果某个对象属性值为null，会形成一个对象的闭环12345678910111213141516171819202122232425let obj = &#123; a: 1, b: 2, c: [1,2,3], d: function() &#123; console.log(&quot;asdfghj&quot;); &#125;&#125;;let result1 = JSON.stringify(target);console.log(result1); // 输出结果为&quot;&#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:[1,2,3]&#125;&quot;，函数直接没了const obj = &#123; foo: &#123; name: &apos;foo&apos;, bar: &#123; name: &apos;bar&apos; baz: &#123; name: &apos;baz&apos;, aChild: null // 待会将指向obj.bar &#125; &#125; &#125;&#125;obj.foo.bar.baz.aChild = obj.foo // foo-&gt;bar-&gt;baz-&gt;aChild-&gt;foo形成环JSON.stringify(obj) // =&gt; TypeError: Converting circular personucture to JSON 好了，最后贴上jquery深拷贝的代码和自己一些理解的注释1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859$.fn.extend = function () &#123; //jquery喜欢在初始定义好所有的变量 let options,// 被拷贝的对象 name,// 遍历时的属性 src,// 返回对象本身的属性值 copy,// 需要拷贝的内容 copyIsArray,// 判断是否为数组 clone,// 返回拷贝的内容 target = arguments[0] || &#123;&#125;, i = 1, length = arguments.length, deep = false;// 默认为浅拷贝 //target 是传入的第一个参数,表示是否要深递归 if(typeof target === &apos;boolean&apos;)&#123; deep = target; //既然为boolean，则此处初始化target为第二个参数或者空对象 target = arguments[i] || &#123;&#125;; // 如果传了类型为 boolean 的第一个参数，i 则从 2 开始 i ++ &#125; //如果传入的第一个参数不是对象或者其他，初始化为一个空对象 if(typeof target !== &apos;object&apos; &amp;&amp; $.isFunction(target))&#123; target = &#123;&#125;; &#125; //如果只传入了一个参数，表示是jquery静态方法，直接返回自身 if(i === length)&#123; target = this; i --; &#125; for(; i &lt; length; i ++)&#123; if((options = arguments[i]) !== null )&#123; for( name in options)&#123; src = target[name];//获得源对象的值 copy = options[name];//获得要拷贝对象的值 //说是为了避免无限循环，例如 extend(true, target, &#123;&apos;target&apos;:target&#125;); if(target === copy) continue; //如果是数据正确，且是一个纯粹的对象（纯粹的对象指的是 通过 &quot;&#123;&#125;&quot; 或者 &quot;new Object&quot; 创建的）或者是一个数组的话 if(deep &amp;&amp; copy &amp;&amp; ($.isPlainObject(copy) || (copyIsArray = Array.isArray(copy))))&#123; //如果是一个数组的话 if(copyIsArray)&#123; copyIsArray = false; clone = src &amp;&amp; Array.isArray(src) ? src : [];//判断源对象是不是数组，如果不是，直接变为空数组，拷贝属性高优先原则 &#125; else &#123; clone = src &amp;&amp; $.isPlainObject(src) ? src : &#123;&#125;;//判断原对象属性是否有值，如果有的话，直接返回原值，否则新建一个空对象 &#125; //继续深拷贝下去 target[name] = $.extend(deep,clone,copy); &#125;else if(copy !== undefined)&#123; //如果不为空，则不是需要深拷贝的数据和对象，而是string,data,boolean等等，可以直接赋值 target[name] = copy; &#125; &#125; &#125; &#125; // 返回新的拷贝完的对象 return target;&#125; 在看上段代码中，又发现了几个好方法在业务中会用到的，可以让代码更严谨12345678910111213141516171819202122232425//判断数据类型//判断是否为纯正的数据对象isPlainObject: function( obj ) &#123; //如果数据不正确，不是对象类型，或者是dom对象，window对象，则直接返回false if ( !obj || jQuery.type(obj) !== &quot;object&quot; || obj.nodeType || jQuery.isWindow( obj ) ) &#123; return false; &#125; //这段代码是为了兼容IE89存在的，查看是否有constructor属性，如果没有必然是数据对象 try &#123; if ( obj.constructor &amp;&amp; !core_hasOwn.call(obj, &quot;constructor&quot;) &amp;&amp; !core_hasOwn.call(obj.constructor.prototype, &quot;isPrototypeOf&quot;) ) &#123; return false; &#125; &#125; catch ( e ) &#123; return false; &#125; //对象中key的顺序会将自身属性排在最前面遍历，如果最后一个还是自身属性，则必然所有属性都是自己的 var key; for ( key in obj ) &#123;&#125; return key === undefined || core_hasOwn.call( obj, key );&#125;, 以上基本就是jquery.extend代码的解析了。extend是jquery中一个极其重要的方法，jquery本身就用它扩展了许多静态方法和实例方法]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>技术文章</tag>
        <tag>javascript</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise源码解析（译）]]></title>
    <url>%2F2017%2F08%2F20%2Fpromise%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E8%AF%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最新项目中有用promise几个api，对代码结构看起来的确很爽。然后想着去网上找了几篇promise库源码解析的文章。但是看了几篇，感觉还是不能够很理解，然后看到一篇翻译文章有说道q.js库的作者有对promise实现的递进讲解，看了一下，还不错， Q.js作者源码分析：Q.js作者promise递进讲解实现 网上找的promise源码翻译。文章有些地方翻译的很好，但是对比原文发现少了一些内容，所以读起来很不顺畅。所以自己根据原文也翻译了一遍。对了，本文适合用过promise的人阅读。如果你还没有接触过。可以右转阮一峰的promise讲解 一、极简版异步回调假如你正在写一个函数不立即返回值函数，需要等待几秒钟后才返回执行结果，你会怎么写呢？思考几秒钟。 最简单的做法自然是写一个回调函数依靠定时器来返回值，比如下面这个12345var oneOneSecondLater = function (callback) &#123; setTimeout(function () &#123; callback(1); &#125;, 1000);&#125;; 这是一个很简单解决问题的方法，但是还有改进的地方，比如能够添加代码执行错误时给出提示。 12345678910var maybeOneOneSecondLater = function (callback, errback) &#123; setTimeout(function () &#123; //进行判断情况，是执行成功的回调，还是执行错误的回调 if (Math.random() &lt; .5) &#123; callback(1); &#125; else &#123; errback(new Error(&quot;Can&apos;t provide one.&quot;)); &#125; &#125;, 1000);&#125;; 一般的做法是提供一个能同时返回值并且能抛出错误的工具。上面这个例子则演示同时提供回调和错误处理。但是这种写法实在是太定制化了，并不好。 二、Promise基本雏形设计所以考虑到大多数的情况，代替最简单的返回值和抛出异常，我们更希望函数通常会返回一个对象用来表示最后执行成功或者失败的结果，而这个返回的对象就是promise。从名字上理解，promise表示承诺，那么最终这个promise（承诺）是要被resolve（履行，执行）掉的。 接下去我们开始迭代设计promise。我们先设计一个具有“then”方法的promise模型，通过“then”方法，我们能注册回调函数并且延迟执行。 12345678910111213var maybeOneOneSecondLater = function () &#123; var callback; setTimeout(function () &#123; callback(1); &#125;, 1000); return &#123; then: function (_callback) &#123; callback = _callback; &#125; &#125;;&#125;;maybeOneOneSecondLater().then(callback1); 代码写好了。但是大家仔细观察发现该方案仍然还有两个缺点 一是现在方案只能执行一个添加的回调函数。最好的做法是每一个通过then添加进来的回调都能被通知到然后顺序执行。 二是如果这个回调函数是在promise创建好1s之后通过then添加进去，它将无法被调用。 敲黑板，注意注意，接下去开始慢慢搭建promise了。 正常情况下，我们希望可以接收任何数量的回调，且不管是否超时，仍然可以继续注册回调。为了实现这些，我们将创建一个包含两个功能的promise对象。 我们暂时设计了一个defer对象，他的返回值一个包含两部分的对象（这个对象就是promise），一个用来注册观察者（就是”then方法添加回调），一个用来通知所有的观察者执行代码（就是resolve去执行之前添加的所有回调）。 当promise没有被resolve之前，所有回调函数会存储在一个”pengding”的数组中。 当promise被resolve之后，立即执行之前存储的所有回调函数，当回调函数全部执行完毕之后，我们将根据”pengding”来区分状态。 12345678910111213141516171819202122232425262728let defer = () =&gt; &#123; let pending = [],value; return &#123; resolve(_value)&#123; value = _value for(let i = 0;i &lt; pending.length; i++)&#123; pending[i](value) &#125; pending = undefined; &#125;, then(_callback)&#123; if(pending)&#123; pending.push(_callback) &#125;else&#123; _callback(); &#125; &#125; &#125;&#125;let oneOneSecondLater = () =&gt; &#123; let result = defer(); setTimeout(()=&gt; &#123; result.resolve(1); &#125;, 1000); return result;&#125;;oneOneSecondLater().then(callback); 这开始的第一步很关键啊，因为此时我们已经可以做到 可以任意时间添加任意多的回调; 可以人为决定什么时候resolve; 当promise被resolve之后，还可以添加回调，只不过此时立即就执行了 但是还有一些问题，比如 defer可以被resolve执行多次,我们并没有给出一个错误的提示。而且事实上为了避免恶意或者无意的不断去resolve，我们仅允许第一次调用可以通知回调并执行。 添加回调只能通过defer.then添加，不能链式调用,即defer.then(callback).then(callback) 那么接下来我们先修正第一个问题1234567891011121314151617181920212223let defer = () =&gt; &#123; let pending = [],value return &#123; resolve(_value)&#123; if(pending)&#123; value = _value for(let i = 0;i &lt; pending.length; i++)&#123; pending[i](value) &#125; pending = undefined; &#125;else&#123; throw new Error(&quot;A promise can only be resolved once.&quot;) &#125; &#125;, then(_callback)&#123; if(pending)&#123; pending.push(_callback) &#125;else&#123; _callback(); &#125; &#125; &#125;&#125; 好，现在我们已经保证不能重复defer.resolve()的问题了，那么我们还希望可以实现通过链式调用来添加回调。可是目前要只能通过defer().then(callback1),defer().then(callback2),defer().then(callback3)这种方式添加回调，这显然不是我们想要的方式。接下来我们将一步一步实现。 三、promise职责分离但是在实现链式回调之前，为了后期结构，我们希望对我们的promise进行职责区分，一个注册观察者，一个执行观察者。根据最少授权原则，我们希望如果授权给某人一个promise，这里只允许他增加观察者；如果授权给某人resolver，他应当仅仅能决定什么时候给出解决方案。因为大量实验表明任何任何不可避免的越权行为会导致后续的改动变得很难维护。（其实就是希望把添加回调的then功能移植到promise中，从defer.then转变成defer.promise.then，保证功能的纯粹性） 12345678910111213141516171819202122232425let defer = () =&gt; &#123; let pending = [],value; return &#123; resolve(_value)&#123; if(pending)&#123; value = _value for(let i = 0;i &lt; pending.length; i++)&#123; pending[i](value) &#125; pending = undefined; &#125;else&#123; throw new Error(&quot;A promise can only be resolved once.&quot;) &#125; &#125;, promise: &#123; then (callback) &#123; if (pending) &#123; pending.push(callback); &#125; else &#123; callback(value); &#125; &#125; &#125; &#125;&#125; 当职责分离完之后，我们就可以接下去实现一步关键的改造 四、promise的链式调用上文说道要实现链式回调，我们首先要能在下一个回调函数里接受上一个回调的值。依靠上一步的职责分离的基础，我们接下来要跨非常大的一步，就是使用旧的promise去驱动新的promise。我们希望通过promise组合的使用，来实现值的传递。 举个例子，让你写一个相加的函数，接受两个回调函数返回的数字相加。大家可以考虑如何实现。12345678910111213141516171819var twoOneSecondLater = function (callback) &#123; var a, b; var consider = function () &#123; if (a === undefined || b === undefined)return; callback(a + b); &#125;; oneOneSecondLater(function (_a) &#123; a = _a; consider(); &#125;); oneOneSecondLater(function (_b) &#123; b = _b; consider(); &#125;);&#125;;twoOneSecondLater(function (c) &#123; // c === 2&#125;); 上面这个方法虽然做到了，但是这个方法是脆弱的，因为我们在执行相加函数时，需要额外的代码去判断相加的数字是否有效。 于是我们希望用更少的代码去实现上面的需求，比如就像下面这样12345678//上面的函数如果用更少的步骤来表达就是var a = oneOneSecondLater();var b = oneOneSecondLater();var c = a.then(function (a) &#123; return b.then(function (b) &#123; return a + b; &#125;);&#125;); 上面这个例子其实想表达的就是实现callback返回值的传递，如callback1的返回值传给callback2，将callback2的返回值传给callback3。为了实现上面例子的这种效果，我们要实现以下几点 每个then方法后必须要返回一个promise 每一个promise被resolve后，返回的必然是一个新的promise或者是一个执行过的值 返回的promise最终可以带着回调的值被resolve掉（这句话有点难翻译，感觉就是promise.resolve(_value)）; 我们实现一个函数可以将获得的值传给下一个回调使用1234567let ref = (value) =&gt; &#123; return &#123; then(callback)&#123; callback(value); &#125; &#125;&#125; 不过考虑到有时候返回的值不仅仅是一个值，而且还可能是一个promise函数，所以我们需要加个判断12345678910let ref = (value) =&gt; &#123; if(value &amp;&amp; typeof value.then === &quot;function&quot;)&#123; return value; &#125; return &#123; then(callback)&#123; callback(value); &#125; &#125;&#125; 这样子我们在使用中就不需要考虑传入的值是一个普通值还是一个promise了。 接下来，为了能使then方法也能返回一个promise，我们来改造下then方法；我们强制将callback的返回值传入下一个promise并立即返回。这个例子存储了回调的值，并在下一个回调中执行了。但是上面第三点没有实现，因为返回值可能是一个promise，那么我们继续改进一下方法 12345678910let ref = (value) =&gt; &#123; if(value &amp;&amp; typeof value.then === &quot;function&quot;)&#123; return value; &#125; return &#123; then(callback)&#123; return ref(callback(value)); &#125; &#125;&#125; 通过这一步增强之后，基本上就可以做到获得上一个回调值并不断链式调用下去了。 接下去我们考虑到一种比较复杂的情况，就是defer中存储的回调会在未来某个时间调用。于是我们需要在defer里面将回调进行一次封装，我们将回调中执行完后通过then方法去驱动下一个promise并传递一个返回值。 此外，resolve方法应该能处理本身是一个promise的情况，resolve可以将值传递给promise。因为不管是ref还是defer都可以返回一个then方法。如果promise是ref类型的，将会通过then(callback)立即执行回调。如果是promise是defer类型的，callback暂时被存储起来，依靠下一个then(callback)调用才能执行；所以变成了callback可以监听一个新的promise以便能获取完全执行后的value。 根据以上要求，得出了下面最终版的promise1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950let isPromise = (value) =&gt; &#123; return value &amp;&amp; typeof value.then === &quot;function&quot;;&#125;;let ref = (value) =&gt; &#123; if (value &amp;&amp; typeof value.then === &quot;function&quot;) return value; return &#123; then (callback) &#123; return ref(callback(value)); &#125; &#125;;&#125;;let defer = () =&gt; &#123; let pending = [], value; return &#123; resolve: function (_value) &#123; if (pending) &#123; value = ref(_value); // values wrapped in a promise for (let i = 0, ii = pending.length; i &lt; ii; i++) &#123; let callback = pending[i]; value.then(callback); // then called instead &#125; pending = undefined; &#125; &#125;, promise: &#123; then: function (_callback) &#123; let result = defer(); // callback is wrapped so that its return // value is captured and used to resolve the promise // that &quot;then&quot; returns let callback = function (value) &#123; result.resolve(_callback(value)); &#125;; if (pending) &#123; pending.push(callback); &#125; else &#123; value.then(callback); &#125; return result.promise; &#125; &#125; &#125;;&#125;;let a = defer();a.promise.then(function(value)&#123;console.log(value);return 2&#125;).then(function(value)&#123;console.log(value)&#125;);a.resolve(1); 将defer分为两个部分，一个是promise，一个是resolve 到了这一步基本上的promise功能已经实现了，可以链式调用，可以在自己控制在未来某个时间resolve。接下去就是功能的增强和补足了。 这一块回调基本上就写完了，看了很久原文的描述，对着代码理解作者想表达的意思。不过英语不太好，写的磕磕绊绊。╮(╯▽╰)╭，感觉还是有些地方写的不对。希望有人能够纠错出来。 五、提供错误的回调为了实现错误消息的传递，我们还需要一个错误的回调函数(errback)。就像promise完全执行时调用callback一样，它会告知执行errback以及告诉我们拒绝的原因。 实现一个类似于前面ref的函数。1234567let reject = (reason) =&gt; &#123; return &#123; then(callback,errback)&#123; return ref(errback(reason); &#125; &#125;&#125; 最简单的实现方法是当监听到返回值时，立即执行代码123reject(&quot;Meh.&quot;).then((value) =&gt; &#123;&#125;,(reason) =&gt; &#123; throw new Error(reason);&#125; 那么接下来我们改进原来promsie这个API，引入“errback”。 为了将错误回调添加到代码中，defer需要添加一种新的容器来添加成功回调和错误回调。因此之前那个存储在数组(pending)中的只有一种待处理回调函数，我们需要重新设计一个同时包含成功回调和错误回调的数组([callback,errback]),根据then传入的参数决定调用哪个。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var defer = function () &#123; var pending = [], value; return &#123; resolve: function (_value) &#123; if (pending) &#123; value = ref(_value); for (var i = 0, ii = pending.length; i &lt; ii; i++) &#123; // apply the pending arguments to &quot;then&quot; value.then.apply(value, pending[i]); &#125; pending = undefined; &#125; &#125;, promise: &#123; then: function (_callback, _errback) &#123; var result = defer(); var callback = function (value) &#123; result.resolve(_callback(value)); &#125;; var errback = function (reason) &#123; result.resolve(_errback(reason)); &#125;; if (pending) &#123; pending.push([callback, errback]); &#125; else &#123; value.then(callback, errback); &#125; return result.promise; &#125; &#125; &#125;;&#125;;let ref = (value) =&gt; &#123; if (value &amp;&amp; typeof value.then === &quot;function&quot;) return value; return &#123; then: function (callback) &#123; return ref(callback(value)); &#125; &#125;;&#125;;let reject = (reason) =&gt; &#123; return &#123; then: function (callback, errback) &#123; return ref(errback(reason)); &#125; &#125;;&#125;; 代码写完了，但是仍然还有地方可以改进。 比如作者说到这一步有一个问题，就是如果按照上面这么写，那么所有的then函数就必须提供错误回调函数(_errback)，如果不提供就会出错。所以最简单的解决方法是提供一个默认的回调函数。甚至文中还说，如果仅仅是对错误回调有需要，那么忽略不写成功回调(_callback)也是可以的。所以为了满足需求，我们为_callback和_errback都提供一个默认的回调函数。（好吧，其实我就是觉得这是一个好的库的容错处理）12345678910111213141516171819202122232425262728293031323334var defer = function () &#123; ... return&#123; ... promise : &#123; then: function (_callback, _errback) &#123; var result = defer(); // 提供一个默认的成功回调和错误回调 _callback = _callback || function (value) &#123; // 默认执行 return value; &#125;; _errback = _errback || function (reason) &#123; // 默认拒绝 return reject(reason); &#125;; var callback = function (value) &#123; result.resolve(_callback(value)); &#125;; var errback = function (reason) &#123; result.resolve(_errback(reason)); &#125;; if (pending) &#123; pending.push([callback, errback]); &#125; else &#123; value.then(callback, errback); &#125; return result.promise; &#125; &#125; &#125; &#125; &#125; 好了，现在我们已经实现了接收构造或者隐含的错误回调这一步的完成版 六、安全性和稳定性我们还有需要需要提高的地方就是要保证callbacks和errbacks在未来他们被调用的时候，应该是和注册时的顺序是保持一致的。这将显著降低异步编程中流程控制出错可能性。文中举了一个有趣的小例子.123456789var blah = function () &#123; var result = foob().then(function () &#123; return barf(); &#125;); var barf = function () &#123; return 10; &#125;; return result;&#125;; 上面这个函数在执行后会出现两种情况，一是抛出一个异常，二是顺利执行并返回了值10。而决定是哪个结果的是foob()是否在正确顺序里。因为我们希望哪怕回调在未来被延迟执行了，它能够执行成功。 下面添加了一个enqueue方法，我的理解就是依靠setTimeout的异步将所有回调按照顺序添加到任务队列中，保证按照顺序执行代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778let enqueue = (callback) =&gt; &#123; setTimeout(callback,1)&#125;let enqueue = (callback) =&gt; &#123; //process.nextTick(callback); // NodeJS setTimeout(callback, 1); // Naïve browser solution&#125;;let defer = function () &#123; let pending = [], value; return &#123; resolve: function (_value) &#123; if (pending) &#123; value = ref(_value); for (let i = 0, ii = pending.length; i &lt; ii; i++) &#123; enqueue(function () &#123; value.then.apply(value, pending[i]); &#125;); &#125; pending = undefined; &#125; &#125;, promise: &#123; then: function (_callback, _errback) &#123; let result = defer(); _callback = _callback || function (value) &#123; return value; &#125;; _errback = _errback || function (reason) &#123; return reject(reason); &#125;; let callback = function (value) &#123; result.resolve(_callback(value)); &#125;; let errback = function (reason) &#123; result.resolve(_errback(reason)); &#125;; if (pending) &#123; pending.push([callback, errback]); &#125; else &#123; // XXX enqueue(function () &#123; value.then(callback, errback); &#125;); &#125; return result.promise; &#125; &#125; &#125;;&#125;;let ref = function (value) &#123; if (value &amp;&amp; value.then) return value; return &#123; then: function (callback) &#123; let result = defer(); // XXX enqueue(function () &#123; result.resolve(callback(value)); &#125;); return result.promise; &#125; &#125;;&#125;;let reject = function (reason) &#123; return &#123; then: function (callback, errback) &#123; var result = defer(); // XXX enqueue(function () &#123; result.resolve(errback(reason)); &#125;); return result.promise; &#125; &#125;;&#125;; 虽然将需要的回调依照次序添加到了队列中 作者有考虑到一些新的问题，比如 callback或者errback必须以同样的顺序被调用 callback或者errback可能会被同时调用 callback或者errback可能会被调用多次 于是我们需要找个机会then的回调函数，为了保证当回调函数中程序出错时，可以转入到报错函数中。(其实又是一个库的容错处理，保证代码出错时不中断程序的执行)。 用when方法封装下promise以此阻止错误发生，确保不会有哪些突发性的错误，包括哪些非必需的事件流控制，并且也能使callback和errback各自保持独立。 123456789101112131415161718192021222324252627282930313233343536373839404142var when = function (value, _callback, _errback) &#123; var result = defer(); var done; _callback = _callback || function (value) &#123; return value; &#125;; _errback = _errback || function (reason) &#123; return reject(reason); &#125;; var callback = function (value) &#123; try &#123; return _callback(value); &#125; catch (reason) &#123; return reject(reason); &#125; &#125;; var errback = function (reason) &#123; try &#123; return _errback(reason); &#125; catch (reason) &#123; return reject(reason); &#125; &#125;; enqueue(function () &#123; ref(value).then(function (value) &#123; if (done) return; done = true; result.resolve(ref(value).then(callback, errback)); &#125;, function (reason) &#123; if (done) return; done = true; result.resolve(errback(reason)); &#125;); &#125;); return result.promise;&#125;; 这一步的完整版 六、消息传递现在这一步来看，promise已经成为了一个具有接受消息功能的类了。Deferred promise根据获得的消息来执行对应的回调函数，返回对应的值。当你接收到完全成功执行的值，则在then中执行成功的回调函数返回msg；获得错误的值则在then中执行错误回调函数，返回错误的原因 因此我们基本可以认为promise这个类可以接受任何的值，包括”then/when”这些信息。这对于一些非立即执行函数的监听非常有用。举个例子，当你发了一个网络请求，等待返回值才能执行函数。我们等待这个请求的往返的过程中浪费了许多时间，而promise仿佛在电脑中另外开了一个线程进行监听这些返回值，然后执行对应的回调函数(这个例子是自己理解举的，非原文，如有不对，欢迎改正)。 翻到这里有点崩溃了，捂下脑子，接下去感觉有点头疼了，以后再补吧,因为基本形态的promise已经出来。接下去是另外一种需求的promise了 接下来我们要包装一种新型的promise，这套promise基于一些能发送任意消息的方法之上，可以满足 “get”, “put”, “post”能发送相应的消息，并且能根据返回结果中执行相应的promise。 第一次尝试翻译，真的是个体力活，花了快2天的时间，整个人都是炸的。不过所幸是比以前明白了一些恭喜。原文大概讲解了基本的promise构成，但是现在还是有许多方法并没有分析，接下去我按照自己的想法去实现以下promise.all方法。如果写的不好，欢迎大家指正，帮我进步一下，谢谢。（手动捂脸）]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>技术文章</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十六章-站在巨人的肩膀]]></title>
    <url>%2F2017%2F08%2F14%2F16.%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86-----%E7%AB%99%E5%9C%A8%E5%B7%A8%E4%BA%BA%E7%9A%84%E8%82%A9%E8%86%80%2F</url>
    <content type="text"><![CDATA[《解释的工具-生活中的经济学原理》—–第十六章-站在巨人的肩膀这章也是本书的最后一章了，看到这里，我不禁问自己两个问题，1.站在经济学的角度，你是否有培养出抽象思考的能力，面对社会的各种现象，是否有一套自己的理论而不是依然人云亦云。2.站在了巨人肩膀上，你是否理解了经济学的思维呢。 第一章节对于人性的分析即生活经济学，让我明白了我们生活中很多不知不觉的习惯其实就是经济学思维的影响，理性与自利的人性，懒惰的天性，信任的价值都是生活中的经济哲学。 第二章的社会经济学则解释了许多社会想象的产生，冷漠的围观者，无情的竞争，残忍的管制都可以由经济学的成本分析。幸运的是，我还相信这中国会变得原来越好，而不是我再网上看到各种黑暗的地方。 第三章政治经济学解释了许多国家政策产生的原因以及我们普通人在这些政策之下受到的影响。无奈的是，虽然我明白了这些政策的最终方向，可是却无法改变自己在大潮下的走势。逆水行舟，不进则退啊。 第四章的法律经济学有时候看得我心惊胆战，世界上是否存在真正的公平与正义，你所看到的真的对的，有价值，有意义的吗？面对真正的选择，跳出自己所在的层面，站在更多更高的角度，也许会发现更多之前没有考虑到的，然后做出的取舍，才显得更加的“公平与正义”。 纵览全书，又人及社会及政治及法律，经济学有由小到大，由点及面，细细解析其所影响的各个层面。归纳出最后4点。 1. 人是理性的，自私的。人们是会思索判断的生物，大多数行为总是为了增添自己（或者自己周围人的福祉）。引申出来的许多懒惰的特性也是由此而来。 2. 存在不一定合理，但是存在一定是有原因的。正是因为行为都是基于理性和自私，所以近年来出现许多冷漠的社会现象（冷眼围观，碰瓷，污蔑）。这些社会现象的出现，都有背后条件的支持————存在不一定合理，但是存在一定是有原因的。 3. 好的价值要出现，是有条件的每个人都希望自己有好的环境，事业上有好的发展，可是这必须你做出一些努力，父母朋友间的互动，自身努力获得好的经济等等。个人小的价值尚且需要这些努力，更大的价值当然需要更困难的条件来支持。所以说，好的价值的出现，是有条件的 4. 一件事物的意义，是由其他事物衬托出来的。最后要说的是我们生活中许多隐含经济学的经验和原则，都是你所在相对环境形成的。如果环境发生改变，则你自己原先所认定的原则自然也会随之发生变化（你要学会拥抱变化）。因此事物的意义，是相对于环境里的各种主管条件，是相对的而不是绝对的。 观点在不断的变化，我们不断的在成长。]]></content>
      <categories>
        <category>《解释的工具-生活中的经济学原理》</category>
      </categories>
      <tags>
        <tag>《解释的工具-生活中的经济学原理》</tag>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于vue-cli的webpack优化之路]]></title>
    <url>%2F2017%2F08%2F13%2F%E5%9F%BA%E4%BA%8Evue-cli%E7%9A%84webpack%E4%BC%98%E5%8C%96%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[最近的项目度过了开始忙碌的基建期，也慢慢轻松下来，准备记录一下自己最近webpack优化的措施，希望有温故知新的效果。 项目采用的是vue全家桶，构建配置都是基于vue-cli去改进的。关于原始webpack配置大家可以看下这篇文章vue-cli#2.0 webpack配置分析,文章基本对于文件每行代码都做了详细的解释，有助于更好的理解webpack。项目位置链接 仔细总结了一下，自己的优化基本还是网上流传的那几点 通过 externals 配置来提取常用库，引用cdn 合理配置CommonsChunkPlugin 善用alias dllplugin启用预编译 happypack多核构建项目 不过经过自己的实践最后三点是对自己项目优化最大的。文章也主要对后面几点详细说明一下 对了，我项目引用了vue全家桶一套,jquery以及两个第三方插件，element-ui,echarts，自己项目的组件大概有40个左右 原来打包一个项目所需要的时间基本在35-40秒左右(第二次有缓存会稍微快一点)，但是偶尔来一次大姨妈，时间甚至要到50s左右，我也是醉了。不过大家可以期待一下经过下面这三步优化大概需要多久。 1.使用dllplugin预编译与引用首先为什么要引用Dll？在网上浏览了一些文章后，我发现上除了加快构建速度以外，使用webpack的dll还有一个好处。 Dll打包以后是独立存在的，只要其包含的库没有增减、升级，hash也不会变化，因此线上的dll代码不需要随着版本发布频繁更新。 因为使用Dll打包的基本上都是独立库文件，这类文件有一个特性就是变化不大。当我们正常打包这些库文件到一个app.js里的时候，由于其他业务文件的改变，影响了缓存对构建的优化，导致每次都要重新去npm包里寻找相关文件。而使用了DLL之后，只要包含的库没有升级， 增减，就不需要重新打包。这样也提高了构建速度。 那么如何使用Dll去优化项目呢首先要建立一个dll的配置文件,引入项目所需要的第三方库。这类库的特点是不需要随着版本发布频繁更新，长期稳定。123456789101112131415161718192021222324const webpack = require(&apos;webpack&apos;);const path = require(&apos;path&apos;);module.exports = &#123; entry: &#123; //你需要引入的第三方库文件 vendor: [&apos;vue&apos;,&apos;vuex&apos;,&apos;vue-router&apos;,&apos;element-ui&apos;,&apos;axios&apos;,&apos;echarts/lib/echarts&apos;,&apos;echarts/lib/chart/bar&apos;,&apos;echarts/lib/chart/line&apos;,&apos;echarts/lib/chart/pie&apos;, &apos;echarts/lib/component/tooltip&apos;,&apos;echarts/lib/component/title&apos;,&apos;echarts/lib/component/legend&apos;,&apos;echarts/lib/component/dataZoom&apos;,&apos;echarts/lib/component/toolbox&apos;], &#125;, output: &#123; path: path.join(__dirname, &apos;dist-[hash]&apos;), filename: &apos;[name].js&apos;, library: &apos;[name]&apos;, &#125;, plugins: [ new webpack.DllPlugin(&#123; path: path.join(__dirname, &apos;dll&apos;, &apos;[name]-manifest.json&apos;), filename: &apos;[name].js&apos;, name: &apos;[name]&apos;, &#125;), ]&#125;; 基本配置参数和webpack基本一模一样，相信来看优化的都明白什么意思，我就不解释了。然后执行代码编译文件。(我的配置文件是放在build里面，下方路径根据项目路径需要变动)1webpack -p --progress --config build/webpack.dll.config.js 当运行完执行后，会生成两个新文件在目录同级，一个是生成在dist文件夹下的verdor.js，里面是刚刚入口依赖被压缩后的代码;一个是dll文件夹下的verdor-manifest.json，将每个库进行了编号索引，并且使用的是id而不是name。 接下去你只要去你的webpack配置文件的里的plugin中添加一行代码就ok了。123456789const manifest = require(&apos;./dll/vendor-manifest.json&apos;);......,plugin:[ new webpack.DllReferencePlugin(&#123; context: __dirname, manifest, &#125;),] 这时候再执行webpack命令，可以发现时间直接从40秒锐减到了18-20s左右，整整快了一倍有木有(不知道是不是因为自己依赖库太多了才这样的，手动捂脸)。 2.happypack多线程编译一般node.js是单线程执行编译，而happypack则是启动node的多线程进行构建，大大提高了构建速度。使用方法也比较简单。以我项目为例,在插件中new一个新的happypack进程出来，然后再使用使用loader的地方替换成对应的id123456789101112131415161718192021222324252627282930313233var HappyPack = require(&apos;happypack&apos;);......modules:&#123; rules : [ ... &#123; test: /\.js$/, loader:[ &apos;happypack/loader?id=happybabel&apos;], include: [resolve(&apos;src&apos;)] &#125;, ... ]&#125;,......plugin:[ //happypack对对 url-loader,vue-loader 和 file-loader 支持度有限，会有报错，有坑。。。 new HappyPack(&#123; id: &apos;happybabel&apos;, loaders: [&apos;babel-loader&apos;], threads: 4,//HappyPack 使用多少子进程来进行编译 &#125;), new HappyPack(&#123; id: &apos;scss&apos;, threads: 4, loaders: [ &apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;, ], &#125;)] 这时候再去执行编译webpack的代码，打印出来的console则变成了另外一种提示。而编译时间大概从20s优化到了15s左右(感觉好像没有网上说的那么大，不知道是不是因为本身js比重占据太大的缘故)。 3.配合resolve，善用alias本来是没有第三点的，只不过在搜索网上webpack优化相关文章的时候，看到用人提到把引入文件改成库提供的文件(原理我理解其实就是1.先通过resolve指定文件寻找位置，减小搜索范围；2.直接根据alias找到库提供的文件位置)。 vue-cli配置文件中提示也有提到这一点，就是下面这段代码123456789resolve: &#123; //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名 extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;], //模块别名定义，方便后续直接引用别名，无须多写长长的地址 alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;,//就是这行代码，提供你直接引用文件 &apos;@&apos;: resolve(&apos;src&apos;), &#125; &#125;, 然后我将其他所有地方关于vue的引用都替换成了vue$之后，比如12// import &apos;vue&apos;;import &apos;vue/dist/vue.esm.js&apos;; 时间竟然到了12s，也是把我吓了一跳。。。 然后我就把jquery，axios，vuex等等全部给替换掉了。。。不过变化没有特别大，大概优化到了11s左右，美滋滋，O(∩_∩)O~~。如果有缓存的情况下，基本上大概在9s左右 4.webpack3升级本来是没第四点，刚刚看到公众号推出来一篇文章讲到升级到webpack3的一些新优点，比如Scope Hoisting(webpack2升级到webpack3基本上没有太大问题)。通过添加一个新的插件12345// 2017-08-13配合最新升级的webpack3提供的新功能，可以使压缩的代码更小，运行更快...plugin : [ new webpack.optimize.ModuleConcatenationPlugin(),] 不过在添加这行代码之后，构建时间并没有太大变化。因为它的优点是提供js在浏览器中的运行速度。webpack2会把每个处理后的模块用一个函数包裹起来，导致浏览器中的JS执行效率降低，主要是因为闭包函数降低了JS引擎解析速度。 不过在浏览器中国的实际效果感觉不出来太大差别 然后还有一个是webpack3中所有的模块支持用ID进行标记，如果重复引用相同的模块 5.去除不必要的文件因为要引入代码高亮的highlight.js插件，webpack会引入里面有各个语言的js文件，但是我们项目只需要js,html,css。搜了一下发现网上已经有类似的解决方法了，ContextReplacementPlugin会根据你写的正则去匹配你需要的文件。 而且自己记得webpack3的升级中有个新特性tree shaking就是可以从文件树中去除不必要的文件。 好了基本上感觉就是以上这些效果对项目的优化最大，虽然没有到网上说的那种只要3~4秒时间那么变态，不过感觉基本9-12秒的时间也可以了。]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>技术文章</tag>
        <tag>javascript</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重温vue双向绑定原理]]></title>
    <url>%2F2017%2F08%2F12%2F%E9%87%8D%E6%B8%A9vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[摘要：因为项目刚开始用的vue框架，所以早期也研究了一下他的代码看过相关文章的解析，说说也能说个七七八八。不过今天再去看以前的demo的时候，发现忽然一知半解了，说明当时可能也没有理解透，所以写篇文章让自己理解的更深一些。 本篇文章大多数知识点实在学习了这篇Vue.js双向绑定的实现原理之后避免遗忘，所以写这个温故知新，加强理解。 项目位置链接 一、访问器属性如果稍微看过相关文章的人都知道vue的实现是依靠Object.defineproperty()来实现的。每个对象都有自己内置的set和get方法，当每次使用set时，去改变引用该属性的地方，从而实现数据的双向绑定。简单举例 1234567891011const obj = &#123;&#125;;Object.defineProperty(obj,&apos;hello&apos;,&#123; get(value)&#123; console.log(&quot;啦啦啦，方法被调用了&quot;); &#125;, set(newVal,oldVal)&#123; console.log(&quot;set方法被调用了，新的值为&quot; + newVal) &#125;&#125;)obj.hello; //get方法被调用了obj.hello = &quot;1234&quot;; //set方法被调用了 二、极简双向绑定的实现基于这个原理，如果想实现显示文字根据输入input变化，实现一个简单版的。123456789101112131415161718&lt;input type=&quot;text&quot; id=&quot;a&quot;/&gt;&lt;span id=&quot;b&quot;&gt;&lt;/span&gt;&lt;script&gt; const obj = &#123;&#125;; Object.defineProperty(obj,&apos;hello&apos;,&#123; get()&#123; console.log(&quot;啦啦啦，方法被调用了&quot;); &#125;, set(newVal)&#123; document.getElementById(&apos;a&apos;).value = newVal; document.getElementById(&apos;b&apos;).innerHTML = newVal; &#125; &#125;) document.addEventListener(&apos;keyup&apos;,function(e)&#123; obj.hello = e.target.value; &#125;)&lt;/script&gt; 上面这个实例实现的效果是：随着文本框输入文字的变化，span会同步显示相同的文字内容。同时在控制台用js改变obj.hello，视图也会更新。这样就实现了view-&gt;model，model-&gt;view的双向绑定。 三、拆解任务，实现vue的双向数据绑定我们最终实现下面vue的效果1234567891011&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;text&quot;/&gt;&lt;/div&gt;&lt;script&gt;const vm = new Vue(&#123; id : &quot;app&quot;, data : &#123; text : &quot;hello world&quot; &#125;&#125;)&lt;/script&gt; 1.输入框的文本与文本节点的data数据绑定2.输入框的内容发生变化时，data中的数据也发生变化，实现view-&gt;model的变化3.data中的数据发生变化时，文本节点的内容同步发生变化，实现model-&gt;view的变化 要实现1的要求，则又涉及到了dom的编译，其中有一个DocumentFragment的知识点。 四、DocumentFragment众所周知，vue吸收了react虚拟DOM的优点，使用DocumentFragment处理节点，其性能和速度远胜于直接操作dom。vue进行编译时，就是将所有挂载在dom上的子节点进行劫持到使用DocumentFragment处理节点，等到所有操作都执行完毕，将DocumentFragment再一模一样返回到挂载的目标上。 先实现一段劫持函数，将要操作的dom全部劫持到DocumentFragment中，然后再append会原位置。123456789101112131415&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;text&quot;/&gt;&lt;/div&gt;&lt;script&gt;const app = document.getElementById(&quot;app&quot;);const nodetoFragment = (node) =&gt; &#123; const flag = document.createDocumentFragment(); let child; whild(child = node.firstChild)&#123; flag.appendChild(child);//不断劫持挂载元素下的所有dom节点到创建的DocumentFragment &#125; return flag&#125;const dom = nodetoFragment(app);&lt;/script&gt; 五、数据初始化绑定当已经获取到所有的dom元素之后，则需要对数据进行初始化绑定，这里简单涉及到了模板的编译。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 编译HTML模板 const compile = (node,vm) =&gt; &#123; const regex = /\&#123;\&#123;(.*)\&#125;\&#125;/;//为临时正则表达式，为demo而生 //如果节点类型为元素的话 if(node.nodeType === 1)&#123; const attrs = node.attributes;//学到一个新属性。。。 for(let i = 0;i &lt; attrs.length; i++)&#123; let attr = attrs[i]; if(attr.nodeName === &quot;v-model&quot;)&#123; let name = attr.nodeValue; node.addEventListener(&quot;input&quot;,function (e) &#123; vm.data[name] = e.target.value; &#125;) node.value = vm.data[name]; node.removeAttribute(&quot;v-model&quot;); &#125; &#125; &#125; //如果节点类型为文本的话 if(node.nodeType === 3)&#123; if(regex.test(node.nodeValue))&#123; let name = RegExp.$1;//获取搭配匹配的字符串，又学到了。。。 name = name.trim(); node.nodeValue = vm.data[name]; &#125; &#125; &#125;; //劫持挂载元素到虚拟dom let nodeToFragment = (node,vm) =&gt; &#123; const flag = document.createDocumentFragment(); let child; while(child = node.firstChild)&#123; compile(child,vm);//绑定数据，插入到虚拟DOM中 flag.appendChild(child); &#125; return flag; &#125;; //初始化 class Vue &#123; constructor(option)&#123; this.data = option.data; let id = option.el; let dom = nodeToFragment(document.getElementById(id),this); document.getElementById(id).appendChild(dom); &#125; &#125; const vm = new Vue(&#123; el : &quot;app&quot;, data : &#123; text : &quot;hello world&quot; &#125; &#125;) 通过以上代码先实现了第一个要求，文本框和文本节点已经出现了hello woeld了 六、响应式的数据绑定接下来我们要实现数据双向绑定的第一步，即view-&gt;model的绑定。根据之前那个简单的例子看到，我们实时获取input中的值，通过Object.defineProperty将data中的text设置为vm的访问器属性，通过set方法，当我们在设置vm.data的值时，实现数据层的绑定。在这一步，set中要做的操作是更新属性的值。 12345678910111213141516171819let defineReactive = (obj,key,val) =&gt; &#123; Object.defineProperty(obj,key,&#123; get(val)&#123; return val; &#125; set(newVal,oldVal)&#123; if(newVal === oldVal) return; val = newVal; console.log(val); &#125; &#125;)&#125;;//监听数据let observe = (obj,vm) =&gt; &#123; Object.keys(obj).forEach((key)=&gt;&#123; defineReactive(vm.data,key,obj[key]); &#125;)&#125;; 七、订阅/发布模式（subscribe&amp;publish） text 属性变化了，set方法触发了，可以通过view层的改变实时改变数据，可是并没有改变文本节点的数据。一个新的知识点：订阅发布模式。 订阅发布模式（又称为观察者模式）定义了一种一对多的关系，让多个观察者同时监听一个主题对象，这个主体对象的改变会通知所有观察者对象。 发布者发出通知=&gt;主题对象收到通知并推送给订阅者=&gt;订阅者执行操作 123456789101112131415161718192021222324 // 三个订阅者 let sub1 = &#123;updata()&#123;console.log(1);&#125;&#125;; let sub2 = &#123;updata()&#123;console.log(2);&#125;&#125;; let sub3 = &#123;updata()&#123;console.log(3);&#125;&#125;; // 一个主题发布器 class Dep&#123; constructor()&#123; this.subs = [sub1,sub2,sub3]; &#125; notify()&#123; subs.forEach((sub) =&gt; &#123; sub.updata(); &#125;) &#125; &#125; const dep = new Dep();// 一个发布者 const pub = &#123; publish()&#123; dep.notipy(); &#125; &#125;; pub.publish(); 上图为一个简单实例，发布者执行发布命令，所有这个主题的订阅者执行更新操作。接下去我们要做的就是，当set方法触发后，input作为发布者，改变了text属性；而文本节点作为订阅者，在收到消息后执行更新操作。 八、双向绑定的实现每次new一个新的vue对象时，主要是做了两件事，一件是监听数据：observer(监听数据)，第二个是编译HTML，nodeToFragement(id)。 在监听数据的过程中，会为data中的每一个属性生成一个主题对象。 而在编译HTML的过程中，会为每个与数据绑定的相关节点生成一个订阅者watcher，订阅者watcher会将自己订阅到相应属性的dep中。 在前面的方法中已经实现了：修改输入框内容=&gt;再时间回调中修改属性值=&gt;触发属性的set方法。 接下来要做的是发出通知dep.notify=&gt;发出订阅者的uodate方法=&gt;更新视图。 那么如何将watcher添加到关联属性的dep中呢。 编译HTML过程中，为每一个与data关联的节点生成一个watcher，那么watcher中又发生了什么？12345678910111213141516171819// 每一个属性节点的watcherclass Watcher&#123; constructor(vm,node,name)&#123; Dep.target = this; this.name = name; this.node = node; this.vm = vm; this.update(); Dep.target = null; &#125; update()&#123; //获得最新值，然后更新视图 this.get(); this.node.nodeValue = this.value; &#125; get()&#123; this.value = this.vm.data[this.name]; &#125;&#125; 在编译HTML的过程中，生成watcher12345678910111213let complie = (node,vm)&#123; ...... //如果节点类型为文本的话 if(node.nodeType === 3)&#123; if(regex.test(node.nodeValue))&#123; let name = RegExp.$1; name = name.trim(); node.nodeValue = vm.data[name]; new Watcher(vm,node,name);//在此处添加订阅者 &#125; &#125;&#125; 首先将自己赋给了一个全局变量Dep.target;然后执行了uodate方法，进而执行了get方法，读取了vm的访问器属性，从而触发了访问器属性的get方法，get方法将相应的watcher添加到对应访问器属性的dep中。再次，获取属性的值，然后更新视图。最后将dep.target设置为空，是因为这是个全局变量也是watcher与dep之间唯一的桥梁，任何时间都只能保证只有一个值。（其实就是说全局一个主题，每个订阅者和发布者都是通过这个主题进行沟通。当执行代码时，这个主题接受到一个发布通知，通知完所有订阅者，然后注销掉，用于下一个通知发布。啰嗦了一段就是想讲为什么要设置Dep.target = null）。 123456789101112131415161718192021222324252627// 一个主题发布器class Dep()&#123; constructor()&#123; this.subs = []; &#125; notify()&#123; this.subs.forEach((sub) =&gt; &#123; sub.update(); &#125; &#125; addSub(sub)&#123; this.subs.push(sub); &#125;&#125;let defineReactive = (obj,key,val) =&gt; &#123; let dep = new Dep(); Object.defineProperty(obk,key,&#123; get()&#123; if(dep.target) dep.addSub(dep.target); &#125; set(newVal,oldVal)&#123; if(newVal === oldVal) return; val = newVal; dep.notify(); &#125; &#125;)&#125; 至此，hello world 双向绑定就基本实现了。文本内容会随输入框内容同步变化，在控制器中修改 vm.text 的值，会同步反映到文本内容中。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>技术文章</tag>
        <tag>javascript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十五章-以管窥天]]></title>
    <url>%2F2017%2F08%2F07%2F15.%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86-----%E4%BB%A5%E7%AE%A1%E7%AA%A5%E5%A4%A9%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[《解释的工具-生活中的经济学原理》—–第十五章-以管窥天？工作也慢慢不忙了，生活也慢慢恢复原样了，回到了原来的轨道上面去了。人们的在思考与做每一个决定都是有他的利弊，当下做出的选择。比起做决定，更大的收货是你在做决定时的思维模式。不管你最后的结果怎么样，当你在面对各种现象和问题时，有自己的认知和思索方式，便是你独有的财富。 本章主要想讲述的其实也是这种思维模式的重要性。我们一生中会做出很多选择，你自己有时候也不知道自己做的选择是否正确，就像自己最近感情上做出的选择，你放弃了很多的同时，也会有相应许多的得到的，也许再过了一段时间之后，你会后悔或者遗憾当时你做的选择，但是这就是你在当时情境下自己做的最好的决定。很多事情有两个选项给你选已经是很幸福的事情了。 经济学在生活中的很多表现其实也就是帮我们做出取舍。看电影，吃饭，睡觉等许多事情不仅仅是由事情本身所决定的，更多会受到周围工作，场景，同事等因素影响。经济学擅长将各个因素抽象化，图表化在心中列出来。自己在思考问题时，可以明确，精致，有效的掌握每一个环节，从而归纳出有意义的结果。也许也会在思考对比的过程中，想出更好的替代方案。 这篇看完后其实没有太多可以分析，但是细细思考，最重要的早已在生活中潜移默化的影响了我们。以后在做每个决定时，独立全面的思考决定所带来的利弊，也许几年后在后悔自己sb的举动，但是至少你曾经细致的去想过每个选项，在你当时的情境下做出最好的选择。并且如果你真的当你思考全面当作出后，也不要再纠结了。]]></content>
      <categories>
        <category>《解释的工具-生活中的经济学原理》</category>
      </categories>
      <tags>
        <tag>《解释的工具-生活中的经济学原理》</tag>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写Vue组件踩坑与心得]]></title>
    <url>%2F2017%2F07%2F29%2F%E6%89%8B%E5%86%99Vue%E7%BB%84%E4%BB%B6%E8%B8%A9%E5%9D%91%E4%B8%8E%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[记得以前看过一句话，说市面上任何的UI库都无法满足一个产品的所有需求。 事实上的确如此，产品需求总是千奇百怪。正如我公司现在的产品，引用的是elemen-ui的库，但是无法级联多选，下拉多选的展现形式不对，穿梭框无法上下移动等各种需求逼迫我们只能自己去写组件实现了。 自己手写实现了两个组件之后，先写一篇记录一些坑和学会的新东西 1、子组件不允许修改父组件数据之前在写angular的父子组件传递数据，子组件可以修改父组件传递进来的数据。不过在Vue中子组件不允许修改父组件穿进来的值，以vue举例来说12345678910111213141516171819&lt;!--父组件HTML内容--&gt;&lt;children-component :value=&quot;data&quot;&gt;&lt;/children-component&gt;&lt;!--父组件的js内容--&gt;export default(&#123; data()&#123; return &#123; data : [1,2,3,4] &#125; &#125;&#125;)&lt;!--子组件的js内容--&gt;export default(&#123; props : [&quot;value&quot;], created : &#123; this.value = [5,6,7,8]; &#125;&#125;) 此举会引发一个非常常见的报错， 那么解决方法是什么呢，那就要看你需求了。比如传进来的是一个渲染列表，我需要的只是修改渲染的数据，那么可以emit出去，然后在父组件重新赋值，通过双向绑定，触发子组件的再次渲染。12345678910111213141516171819202122232425&lt;!--父组件HTML内容--&gt;&lt;children-component :value=&quot;data&quot; @changeProp=&quot;changeData&quot;&gt;&lt;/children-component&gt;&lt;!--父组件的js内容--&gt;export default(&#123; data()&#123; return &#123; data : [1,2,3,4] &#125; &#125;, methods : &#123; changeData(value)&#123; this.data = value; &#125; &#125;&#125;)&lt;!--子组件的js内容--&gt;export default(&#123; props : [&quot;value&quot;], created : &#123; this.$emit(&quot;changeProp&quot;,[5,6,7,8]) &#125;&#125;) 例子写的比较简单，其实原理就是emit一个数据到父组件上去，然后在父组件中接受到这个传递上来的新值，将data赋予新值，然后重新传递到了子组件，起到一个变向修改子组件的效果。 被人提醒到一个方法是用.sync，这个方法也是可以的。之前一直以为是被废弃就没用，才发现它其实是在的。看了一下.synv文档，发现这其实是一个语法糖的形式展现出来。如文档所示123456&lt;!--日常使用语法糖形态--&gt;&lt;comp :foo.sync=&quot;bar&quot;&gt;&lt;/comp&gt;&lt;!--↓↓↓↓↓真实形态↓↓↓↓↓↓--&gt;&lt;comp :foo=&quot;bar&quot; @update:foo=&quot;val =&gt; bar = val&quot;&gt;&lt;/comp&gt;&lt;!--子组件js代码--&gt;this.$emit(&apos;update:foo&apos;, newValue) 个人感觉Vue框架其实还是不赞同直接修改数据，但是它帮你定义了一个update事件，让你在子组件可以直接显式调用，不需要自己去定义事件这么麻烦了。大家还是把自定义事件用在一些事件上吧。 2.Vue给每个组件提供了一个默认的父子传递事件v-model。但是你每次父子组件传递数据时，都要父子处定义一个事件是很麻烦的，vue则为每个组件提供了一个默认v-model的语法糖。1234567891011121314151617181920212223242526272829&lt;!--父组件HTML内容--&gt;&lt;children-component v-mode=&quot;data&quot; &gt;&lt;/children-component&gt;&lt;!--父组件的js内容--&gt;export default(&#123; data()&#123; return &#123; data : [1,2,3,4] &#125; &#125;, watch : &#123; //可以在此处监听子组件传递上来的数据 data(n,o)&#123; console.log(n,o); //[5,6,7,8],[1,2,3,4] &#125; &#125;&#125;)&lt;!--子组件的js内容--&gt;export default(&#123; &lt;!--大家注意我下面这行代码是打了注释的，说明我在子组件没有定义任何属性--&gt; // props : [&quot;value&quot;] &lt;!--并且我接下去直接在代码中使用了this.value(一个完全没有定义过的value)。--&gt; created : &#123; console.log(this.value); this.$emit(&quot;input&quot;,[5,6,7,8]); //当我想改变传进来值的时候 &#125;&#125;) 因为之前一直使用ng-model来用于表单组件的传递，所以开始对于v-mode也是这个印象，不过后面看了element-ui的源码才发现我想简单了，然后网上搜了一下对于这个语法糖的解释。12//注意，该组件不是表单组件&lt;children-component :value=&quot;data&quot; @input=&quot;data = arguments[0]&quot;&gt;&lt;/children-component&gt; 看了这行代码大家心里估计也能明白的差不多了，其实Vue只是帮我们把父组件上的两段声明合二为一了，同时再帮我们在子组件处直接省略了定义。语法糖说到底就是帮我们省力的嘛。 3.保留属性key因为在父子组件传递数据的时候，我们会通过在父组件写属性名将属性传递进去，理论上你可以写任何一个属性名a,value,list,data，但是有几个关键字已经被Vue内部保留了,比如下面的key。1234567891011121314151617181920&lt;children-component :key=&quot;data&quot; :value=&quot;list&quot;&gt;&lt;/children-component&gt;&lt;!--父组件的js内容--&gt;export default(&#123; data()&#123; return &#123; data : [1,2,3,4], list : [1,2,4,5] &#125; &#125;,&#125;)&lt;!--子组件的js内容--&gt;export default(&#123; // props : [&quot;value&quot;,&quot;key&quot;] created : &#123; console.log(this.value); console.log(this.key); &#125;&#125;) 当然如果我不在props里面写入key这个属性的话，是不会报错的。 然后想起项目中在写下拉框组件时，如果你对自己以前写的option组件进行repeat的时候，key会作为一个关键字进行标记，不传key的话，vue会给出黄色提醒，不是报错，比如1234567891011121314151617181920&lt;demo-select :optionList=&quot;optionList&quot;&gt; &lt;demo-option v-for=&quot;option in optionList&quot; :key=&quot;option.value&quot; :value=&quot;option.value&quot;&gt;&#123;&#123;option.label&#125;&#125;&lt;/demo-option&gt;&lt;/demo-select&gt;&lt;!--父组件的js内容--&gt;export default(&#123; data()&#123; return &#123; optionList : [&#123;label:1,value:1&#125;,&#123;label:2,value:2&#125;,&#123;label:3,value:3&#125;], &#125; &#125;,&#125;)&lt;!--子组件的js内容--&gt;export default(&#123; // props : [&quot;value&quot;,&quot;key&quot;] created : &#123; console.log(this.value); console.log(this.key); &#125;&#125;) 如果我在对需要repeat的子组件中没有添加:key这个属性的话，则会给出上面的提醒。原因呢，文档里面也有述说,作为每个VNODE唯一标识的id，用于diff对比时更高的效率。不过这是另一个话题了。 好了回到开头，总结性话语就是不要写key传递属性。不过不知道还有没有什么其他的属性我还没有碰到的 4.使用$emit和$on需要对应同一个组件如果一个UI组件内部还分了好几层(3层左右)，且有不止一个事件或者属性需要传递，那么单纯的props和@+事件传递就没有那么方便了。这时候我们会选择$emit,$broadcast和$on。基本使用用法就不介绍了，见官方文档。主要讲其中的一个坑。如果同一个事件$emit,$broadcast和$on不是由同一个组件调用的话，那么传递的值是接收不到的 123456789101112131415161718&lt;parent-component&gt; &lt;children-component&gt;&lt;/children-component&gt;&lt;/parent-component&gt;&lt;!--父组件的js内容--&gt;export default(&#123; mounted()&#123; this.$on(&quot;change&quot;,function(value)&#123;console.log(&quot;接收到了子组件传递上来的信息&quot; + value)&#125;); //此处this指向的父组件 &#125;&#125;)&lt;!--子组件的js内容--&gt;export default(&#123; mounted()&#123; this.$emit(&quot;change&quot;,11111); //此处this指向的子组件 &#125;&#125;) 在上面这一段代码，子组件通过$emit传递一个值上去，但是他是通过调自己（非父组件）用$emit方法。而父组件也是调用自身的$on方法，那么这个$on方法是接收不到传递上来的值的。因为两个组件的this分别指是自己，不是同一个。 如果我们把子组件进行修改一下1234567891011121314151617181920212223&lt;parent-component&gt; &lt;children-component&gt;&lt;/children-component&gt;&lt;/parent-component&gt;&lt;!--父组件的js内容--&gt;export default(&#123; mounted()&#123; //此处this指向的父组件 this.$on(&quot;change&quot;,function(value)&#123;console.log(&quot;接收到了子组件传递上来的信息&quot; + value)&#125;); &#125;&#125;)&lt;!--子组件的js内容--&gt;export default(&#123; computed()&#123; rootParent()&#123; return this.$parent; &#125; &#125; mounted()&#123; this.rootParent.$emit(&quot;change&quot;,11111); //获取到是同一个组件之后进行调用 &#125;&#125;) 这样子就可以成功传递了。但是如果组件内部有好几层的话，直接通过this.$parent.$parent去获取上层父组件比较麻烦。我们希望可以做到不管组件有几层，我都可以直接一步直接获取到父组件进行调用$emit或者$broadcast。那么我们需要单独封装一个方法写在一个文件里面，然后使用的时候进行Mixins合并就好了。12345678910111213141516171819202122232425262728293031323334//Emitter.js 文件export default &#123; methods: &#123; //三个属性分别是父组件名，事件名，传递值 dispatch(componentName, eventName, params) &#123; var parent = this.$parent || this.$root; var name = parent.$options.componentName; while (parent &amp;&amp; (!name || name !== componentName)) &#123; parent = parent.$parent; if (parent) &#123; name = parent.$options.componentName; &#125; &#125; if (parent) &#123; parent.$emit.apply(parent, [eventName].concat(params)); &#125; &#125;, broadcast(componentName, eventName, params) &#123; broadcast.call(this, componentName, eventName, params); &#125; &#125;&#125;;//然后在引用文件进行引入并且调用import Emitter from &quot;Emitter.js&quot;export default &#123; mixins: [Emitter], mounted()&#123; this.dispatch(&apos;parentComponent&apos;,&quot;change&quot;,1111) &#125;&#125; 5.全局一次性引用写好的组件假如我们写好了一些组件，接下去肯定还要引入和使用吧。但是你写了这么多组件，在每个地方一个个引用想要的是一件很麻烦的事情。我们最好是在一个初始的地方一次性全部引入，然后在用的地方直接使用 (当然全部引入的话，无可避免的会引入和打包不需要的东西，不过这是公共组件库的烦恼，我们自己写的肯定会全部用到)。 12345678910111213// 在文件开头初始引入所有的组件文件import b from &quot;./components/common/b.vue&quot;import c from &quot;./components/common/c.vue&quot;const components = [b,c];const install = function (Vue, opts = &#123;&#125;) &#123; components.map(component =&gt; &#123; Vue.component(component.name, component); &#125;);&#125;;export default install 然后直接在启动的main.js文件里面引入就好12import ui from &quot;install.js&quot;Vue.use(ui); 然后你就可以随意在任何一个组件里面直接调用了，比自己之前在每个组件里重复调用要方便一点。12&lt;b v-model=&quot;data1&quot;&gt;&lt;/b&gt;&lt;c v-model=&quot;data2&quot;&gt;&lt;/c&gt; 好了，暂时到这里，都是自己的踩得坑和心得，希望对大家有所帮助吧，接下去还有的话再补充好了。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>技术文章</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十四章-司法女神的举止]]></title>
    <url>%2F2017%2F07%2F27%2F14.%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86-----%E5%8F%B8%E6%B3%95%E5%A5%B3%E7%A5%9E%E7%9A%84%E4%B8%BE%E6%AD%A2%2F</url>
    <content type="text"><![CDATA[《解释的工具-生活中的经济学原理》—–第十四章-司法女神的举止好久好久没有看书了，一是因为最近的项目是在是太紧张了，要赶在deadline前完成，同时手贱半个月前空的时候接了个私活，更加忙的不可开交。好不容易等忙完了，好了，吃了个特辣的香锅整个人身体垮了。也算明白了一个道理，欠的账总是要还的。你加班忙碌期的疲惫会在你松懈下的那一刻爆发不来的。 好了，回到正题 这是法律经济学的最后一篇。之前的对此有的印象似乎已经有点模糊了。只记得法律经济学告诉我们许多法律上的制定可以由经济效益为出发点进行考虑，会发现许多案例有不一样的发现。 本章最明显的一个例子是火车撞小孩的故事，一个小孩在看清楚了告示之后在不会有火车经过的铁轨上玩耍，而另外5个小孩却仍然在火车要通过的铁道上玩耍。没过多久，火车匆匆而至，身为扳道工的你是否会让火车转入另一条，去撞那位对的小孩呢?? 这个故事很久之前就看到过，我心目里的答案一直不该，因为一个人做错事就应该受到惩罚，凭什么让对的人替错的人去牺牲生命。法律上对就是对，错就是错，如果法律不支持对的事情，那么法律的尊严将消失的无影无踪。在文中则给出了另外几种思路，比如从小孩成长后的价值，5个富孩子家庭背景去弥补穷孩子的损失。这几种说法虽然角度独特，却也没有给予我震动感。不过当文中说道如果是100个孩子呢，1000个孩子呢，那么你是否还会去撞吗？ 我感觉我的想法已经改变了，我也许会去牺牲那个人吧。法律固然是公平与正义的，可是在规则与例外之间的取舍，却显得更加慎重与微妙。（好吧，人们总能自圆其说，找到理由来暗示自己） 法律中一些规则的制定是否需要考虑情理之外的的东西。以火车撞小孩子为例，当你动摇了内心不扳轨道的决定，就说明你已经考虑了情理之外的东西，而不止是法律的公平正义了。现实中其实的确是有许多规则属于这种。对于“恋童癖”判处重刑甚至死刑就属于这个，需要加重惩罚来进行宣示警醒的作用，防患于未然，才能更好的保护孩子。而对未成年人减轻惩罚，对犯人减刑，则是因为他们未来可能会有更大更好的价值。不同的表现都是具有不同的价值的，惩罚是善后的补救措施，遏阻则是着眼于未来长远利益的展望。 哎，真的是感觉从法律经济学的角度去考虑，很多事情则都没有了法律的公平正义可言了。司法女神的尊严真的因为各种各样的情理，价值受到了极大的挑战啊。]]></content>
      <categories>
        <category>《解释的工具-生活中的经济学原理》</category>
      </categories>
      <tags>
        <tag>《解释的工具-生活中的经济学原理》</tag>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十三章-司法有价吗？]]></title>
    <url>%2F2017%2F07%2F06%2F13.%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86-----%E5%8F%B8%E6%B3%95%E6%9C%89%E4%BB%B7%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[《解释的工具-生活中的经济学原理》—–第十三章-司法有价吗？万万没有想到距离上一篇写的文章已经过去了一个月了，看样子最近这个月的工作任务真是太大了。如果用经济学的角度去解析，之所以这么久不工作，只因为我写文章带来的收益没有我最近做项目带来的收益大。我看书加写文章所付出虽然看上去只有一小时的成本，可是这一小时从当下来看，没有为我带来任何收益，我自然会将事情的顺序排在后面。 好了，回到正题，本篇讲的是法律经济学。其实在看书的途中，我也越来越感受到文章想表达的东西，在我理解来看，其实就是成本和收益的问题。付出多少成本，拿到多少收益，怎么样实现最大成本收益比，其实就是以经济学的角度去考虑问题。文中提出来的几个事例，如违章过马路收取过路费，有些人愿意缴费用来赶时间，有人愿意0成本过马路，其实都是各自对自己时间效益的评估。政府采用收费来限制行人，而不是竖警示牌，宣传教育，也是因为觉得这样子的收益比是最高的。所以司法有价吗？缴费违章过马路对吗？过马路这件事当然不对，违法；但是我缴费也是合法维护了规则秩序，所以最终这件事只不过合乎法，违于礼而已。 文中还有一个教育部长的例子也更加证明了经济学在政府中政策的影响。教育部长站在教育领域，希望政府支持更多的精力花在特殊儿童的教育上，他拿出美国一位残疾儿童在三位医护人员的帮助下获取文学奖的例子为佐证，希望发掘更多特殊人才的潜力。可是在商言商，特殊教育固然重要，可是教育领域中的童年教育，初中教育也很重要，如果把资源集中在这一块，是不是也能发挥更多的用处呢。如果在提高一层，站在国家角度，你‘教育‘重要，那么‘环保’重要吗？‘安防’重要吗？等等重要吗？这么一对比，花在特殊教育上的资源还值得吗？教育部长的话站在自身的角度当然也没有错，合乎情理，只不过一旦吧层次提高站在更高的决策位角度，许多问题就从绝对性变为了相对性。所以教育和面包谁更重要呢？ 随着这本书越读越多，其实你也能明白，真正的公平正义是没有的，对公平正义的追求，是建立在一个稳定，成熟的社会，和其背后所愿意付出的资源。司法女神希望世界充满公平，可是她也只能环抱胸前有限的空间。]]></content>
      <categories>
        <category>《解释的工具-生活中的经济学原理》</category>
      </categories>
      <tags>
        <tag>《解释的工具-生活中的经济学原理》</tag>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十二章-公平正义的真正意义]]></title>
    <url>%2F2017%2F06%2F08%2F12.%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86-----%E5%85%AC%E5%B9%B3%E6%AD%A3%E4%B9%89%E7%9A%84%E7%9C%9F%E6%AD%A3%E6%84%8F%E4%B9%89%2F</url>
    <content type="text"><![CDATA[《解释的工具-生活中的经济学原理》—–第十二章-公平正义的真正意义第十二章实在是自己政治理解能力不够，看完都还是有点懵懂的，决定还是跨过去了。过两天抽个时间再看一遍，看看温故能不能知新。 接下去几章是法律经济学，其实还是和我们周围的生活有一些息息相关的。看完之后，仔细琢磨了生活中一些规章制度，的确隐含着很多法律经济学的影子。 就我理解来说,法律经济学的观点是衡量一件法律案件是否有理，不应该从绝对的公平正义角度着眼，而值得从经济效益的角度进行评估。 我仔细想想我们公司有些制度也有异曲同工之妙。以孕妇请假为例，假如刚开始的时候公司没有任何相关规定，那么第一位孕妇在刚开始怀孕的时候，可以带薪请假并且同时无条件享受公司各种各样的福利，那么她这种行为会不会对其他人造成心理上的伤害；她同时也在透支的后面孕妇的福利，因为如果她做的这么过分，意味着后面怀孕的人将再也无法享受到类似的福利，因为公司会从成本角度去衡量。也许让一位孕妇员工享受所有的福利应该是正义的，当时它产生的负面影响将会远远大于对公司正面的生产价值。 再以生活中一个很常见的例子进行举例。一个爱妈妈的广告也许在许多人的眼中感到的是温馨，但是一些从小没有母爱的孤儿长大之后看到这个广告，却引起了一丝被刺伤的愤怒。那么当这些人告广告商的时候，难道因为对一部分人造成了伤害，就禁止播放吗？ 我相信另一部分人肯定会嗤之以鼻，心里默默念一句凭什么，我就觉得广告拍的很好。当然这只是嘴上的吐槽，我们可以更深入到第二层角度去分析。这支广告固然让一部分人愤怒，可是它同时却让更多的人知道抚慰母亲辛劳，提醒子女孺慕，甚至可能会挽回一些破碎的家庭。它产生的社会价值岂不是更大，如果你不喜欢，你可以拒绝购买广告产品，或者促使周围人一起抵制，但是不应该通过法律来限制。因为一旦以法律制度来限定，分寸的掌握就变得很微妙了。。更深程度上去看，如果一个人的喜好可以通过法律强加到另外一个人身上，将心比心，你愿意别人用同样的法律来限制你的信仰和喜好吗？你愿意让制度法律的人又那么大权力吗？ 文末抛出了一个问题？既然播放伤心的广告可以，那么为什么抽烟不行呢？我的理解来看，因为抽烟对于社会生产成本产生危害将远大于其生产价值吧。我想说，如果抽烟有助于环境健康，身体长寿，同时还能帮助人们，促进社会产值。恐怕结果就完全相反了。 本章真的很有意思，文中提出了许多观点在日常生活中都显得那么无话可说。绝对的公平正义如果会将人类带向灭亡，那么他还有意义吗我们应该明白公平正义本身并不是目的，只是手段。既然是手段，也就是工具，我们当然应该选择好的工具。]]></content>
      <categories>
        <category>《解释的工具-生活中的经济学原理》</category>
      </categories>
      <tags>
        <tag>《解释的工具-生活中的经济学原理》</tag>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二章-稻草人的由来]]></title>
    <url>%2F2017%2F06%2F06%2F2.%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86-----%E7%A8%BB%E8%8D%89%E4%BA%BA%E7%9A%84%E7%94%B1%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[《解释的工具-生活中的经济学原理》—–第二章-稻草人的由来本章其实真的很符合我们生活中的经济学原理。开始书中讲到人们一个“贴标签”的行为。人们会不知不觉的给一个人贴上标贴，比如不认识的工作人员，身边的同事和朋友。我们为什么会喜欢上贴标签？ 我经常和周围朋友开玩笑说，懒是推动我们今天便利生活的源泉。而“贴标签”其实也是一个人们一个偷懒的行为。胖的人心胸狭窄，瘦的人工余心计，上海人华而不实，北京人趾高气扬（网上地域黑中常见的言论，这不是标签，更多是恶意的栽赃）。当我们给一个个接触的人打上一个标记之后，将事情简单化，然后根据自己的假设。我们可以很快从以往的经验中取舍自己的行为，然后根据“标签”自身发生的微妙变化，加减一些新的属性，根据这些属性继续调整自己，于是我们终于可以简单的进行交往行事了。所以，贴标签其实是有功用的，可以降低我们行为的成本。 但是，贴标签也有他不好的一面。前段时间我的一个好朋友经历了一些事情，一个交往多年的朋友做了一件让她感到意外，并且伤害到她的事情。我在和她不断的交流中，也得出了一些的感悟。我们在和朋友的交往中，如果一个标签贴的成功，并且始终没有改变，它会不断的加深我们的印象。随着时间的流逝，这个人的标签会在我们心中越来越深，如果这时候他做了一件完全不符合你这个“标签”的事情，从而彻底打破自己以往的印象，对于一些感性的人来说，真是一件崩溃的事情。因为它完全打破了你以往认知人的准则。最后你将撕下自己多年认知的标签，而打上另一个完全相反的标签，对于心理上的打击，不是亲身经历是感受不到的。这种感觉，更像是 “背叛“。 另外一个典型就是由于摘标签过于麻烦，所以人们不会轻易改变对一个人的印象。比如当我初次在交往中因为一件小事给人打上“爱占便宜”的标签，我与他之后的交往都会有这方面的考虑。虽然事实上他并不是这样的人，但是又如何呢，我并没有因为这个标签吃亏呀，我为什么要改变呢。人们总会成长与改变，切勿因为一次事件而固执自己的观点。作为一个互联网人，你须记住，唯一不变的是变化。 降低成本，真的是人们许多行为背后最主要的推动力之一啊。 由点及面，由人到社会。贴标签是降低个人成本的行为，那么制度则更像是降低人们在社会生活成本的代表。制度可能是一种局限行为的束缚，但是也是人们利用的一种资产。 在一些带部队的纪录片中，更讲究强调“带兵带心”，而不是“带兵带行”。源于人们只有从心底里认可一样东西之后，才会不自觉的去遵守它。许多规章制度也是一样的道理，如果每个人都可以遵守一项制度成本，那么人们在社会中生活的成本也会降低很多。 如果在道路上只有一个人，那么我们想怎么走就怎么走，但是当有各种不同性格，年龄，性别的人处在同一环境的时候，我们会不自觉的做出一些公共的行为，时日一久，大家基本遵守这种行为时，一个为众人支持和运用的小制度就诞生了。当团队里面的人越来越多，接触越来越频繁，交往越来越复杂的时候，自然而然的需要更多的规章制度。不过制度的关键还是依赖于人，人们首先要相信这个制度，才能遵守和执行。书中有一个故事很典型，美国加州一个市政府将土地低价卖给了一个财团，用于创造就业机会和拉升当地消费行为，获得更多的营业税和财收税。但是如果这个新闻出现在中国，经过新闻媒体的报道，人们首先想到的就是政府与财团的狼狈为奸，而不是由此带来的经济效益。这其中的关键点就是信任的问题，也是后面几篇文章中阐述的“社会成本“。社会成本高带来的良性经济循环将会远远甩开反向的恶性循环。]]></content>
      <categories>
        <category>《解释的工具-生活中的经济学原理》</category>
      </categories>
      <tags>
        <tag>《解释的工具-生活中的经济学原理》</tag>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第九章-政治过程的基本元素]]></title>
    <url>%2F2017%2F06%2F01%2F9.%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86-----%E6%94%BF%E6%B2%BB%E8%BF%87%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[《解释的工具-生活中的经济学原理》—–第九章-政治过程的基本元素作者以台湾民主投票的政治环境为基础进行阐述一些不为人知的“尴尬点”，当我想带入其中的时候，才发现中国完全不是这样的。说实话，这一章真的是完全不符合国情，真要代入其中，真的是满满对国家的吐槽。不过第二个故事中隐含的“城市化”思想，感觉和自己的生活更切合一点吧。 大家在观看球赛时，一个观众为了看的更清楚而站了起来，刚开始他当然获得了一览无余的快乐；但是当大家逐渐都站了起来，视野和原先都没什么两样了。 这个“站起来”的故事，第一想法就是“城市化”。随着“城市化”的政策执行，越来越多好的资源会逐渐往中心城市集中，人们为了获得好的资源，也会逐渐地，慢慢地迁往城市。可是随着人数的增多，城市的资源也越来越稀缺，人们则不得已付出比原来环境更多的努力，比如双职工，加班，双份工作等等，一切为了享受更好的资源。最终随着某个临界点，教育医疗资源的有限，房价的增高，导致一部分人们即时付出了比原先环境更多的努力，却获得和以前一样的资源。那么这时候，你还能退出去吗，你还能离开这个城市嘛？有时候，我们好不容易摸清了一点端倪，却不知道如何挣脱自己造成的困境。 事实上，我们身边许多事情也隐含着一模一样的道理。高峰时期的塞车，孩子的补习班和艺术班，生活中的走后门，送红包。这些行为耗费了我们许多的心力，资源，时间，实际上获得却比想象的少很多。即使大家知道这样，却也没有人愿意首先“坐下来”(当然做的更好也是一条路，可是除非你永远领先，不然最终结果还是会一模一样)。 我有时候也在和身边朋友说：“我还回的去吗？”。我的职业决定了我回去毫无发展前景，只能继续走公务员这条父母眼中的光明大道。杭州作为一个大城市，寄托了我个人所有的希望，因为我知道这是一个我付出多少就能给我多少的城市，这是一个我不需要依靠一些东西可以公平竞争的城市。即使他还有许多的不完美，可以我感觉我已经“坐不下来了”。因为我知道，我如果坐回去，我就永远只能坐在那里了。]]></content>
      <categories>
        <category>《解释的工具-生活中的经济学原理》</category>
      </categories>
      <tags>
        <tag>《解释的工具-生活中的经济学原理》</tag>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第八章-流逝的景观]]></title>
    <url>%2F2017%2F05%2F24%2F8.%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86-----%E6%B5%81%E9%80%9D%E7%9A%84%E6%99%AF%E8%A7%82%2F</url>
    <content type="text"><![CDATA[《解释的工具-生活中的经济学原理》—–第八章-流逝的景观标题名字取得非常的文艺，本篇的核心应该是“变化”两个字，着重讲的是社会环境的变化，也就是文中所说的社会变迁。 是什么引起了社会变迁。文中以一个小西餐馆进行举例，其会员卡的的别样销售给自身带来了利润，可能会引起西餐行业的学习，每家店采取类似的销售方式，甚至之后以这种会员卡模式开始影响了饮食行业。那么为什么一个个体可以引起从量变到质变的过程呢，可能只是因为这么做对自己有利益的产生，从而促使了集体的东施效颦，慢慢的变成了一个行业的标准化。拿今天与10年前相比，许多行业的服务完全不一样，变得越来越好，其实也是由这许许多多的小变化积累而起的，也就是“量变引起的质变”。 （今天有点无从下手，应该是没有理解文章的中心思想吧,也可能是中午太困了，勉强读加勉强写，引以为鉴）结尾的一句话说的很好，人成长的经验，受到环境中既存事物的影响；但是当人参与到社会活动的时候，也会为社会主义增添新的内容，从而影响社会发展的轨迹。我们每一个人在影响着周围其实也是在影响着社会，只不过在社会变迁的过程中，有的被人接纳所以穿的更远，而有的痛苦抗拒，所以可能自己被改变。变化真是一个神奇的东西。 以苏东坡的的一句词来结尾。《前赤壁赋》中，苏东坡说道：”盖将自起变者而观之，则万物曾不能以一瞬；自起不变者而观之，则物与我皆无尽也”。天地万物无时无刻不在变化 最后谈一点自己对变化的感受。今天互联网经常讲的一句话是“唯一不变的是变化”，用来告诫自身不能放松警惕，我也应该时刻注意行业中的变化，不然可能就要被淘汰。自己作为一个前端开发人员，可以说是一个入门门槛很低的职业，但是如果入门之后，则会发现这是一个水很深的职业，也有着许多不同的发展方向。自身应该加强优势，也就是前端方向的深度。或许图形化应该是一个好的方向。框架的知识可以帮你找到一份好的工作，却不能让你在以后甩掉别人。 前天还出了一件事情，就是在科技高速发展的今天，因为有google参与的人机大战直播遭到了政府的封杀。可笑的是，一个在浙江乌镇举行的围棋比赛竟然需要我们翻墙去看，恐怕几年前的互联网氛围都不会这么严肃吧。这个也是变化，只不过可惜的是，这个变化其实是开倒车。前面也说过，发生变化的起因基本上是受到经济活动的影响，可是现在对于互联网的管控越来越严，可见这只看不见的手越来越重视互联网行业。还记得在第四章中，西班牙政府因为债券问题导致的自己信用价值越来越低，极大的拉低了“社会信用“，从而与经济良性循环的英国政府差距越来越大。今天在互联网行业，我也能深深的感受到与美国开放的多元文化融合交流氛围的差距。可笑的是代表大同注意的社会主义，却没有资本主义的言论自由。伤心的是，恐怕只有互联网相关从业者能感受的到这种情况，许多人民大众恐怕根本不关心这gfw的危害吧。]]></content>
      <categories>
        <category>《解释的工具-生活中的经济学原理》</category>
      </categories>
      <tags>
        <tag>《解释的工具-生活中的经济学原理》</tag>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第七章-大道之行也]]></title>
    <url>%2F2017%2F05%2F18%2F7.%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86-----%E5%A4%A7%E9%81%93%E4%B9%8B%E8%A1%8C%E4%B9%9F%2F</url>
    <content type="text"><![CDATA[《解释的工具-生活中的经济学原理》—–第七章-大道之行也小时候读书有一篇文言文《礼记·礼运篇》开篇第一句话就是：大道之行也，天下为公。寓意一个大同的理想社会。本章也是着重从这个角度出发，讲述了一个大同社会大道的关键点—社会资本论。 作者开篇介绍了社会学家和经济学家对同一个问题以不同的角度和方法去分析，也许最后结果大同小异，但是分析维度却千差万别。紧接着通过著名的纽约凶杀案案例，引出核心大问题—在长达二三十分钟的凶杀案里，为什么没有人出手提供帮助。（美国这个案例只是人们不出手帮助，就像今天中国也是这样；但是中国还有一个更恶劣的情况是，人们出手帮助，反而还被诬陷） 其实在现在社会里，因为成本的限制，戴警徽的警察有限，不能及时的出来制止罪恶发生，因此对于法律和善良风俗的维系，主要还是依靠每一个普通大众。但是因为人带有”理性”和”自利“的特征，在做一件事情前总会考虑自己要付出的成本，所以大家便会倾向于置之不理。但假如人们在大到犯罪发生，小到人们乱丢瓜果皮屑时愿意挺身而出，无论是在当时还是事后，能够获得别人的肯定甚至奖励。那么见义勇为的行为也会容易发生。而在大环境的见义勇为和挺身而出下，人们去做相应的事情也更加容易一些。而不是像现在这样，我去制止一个人乱丢纸屑，遭到人们的白眼，同伴的吐槽。 上一种方法更倾向于从正面肯定，还有一种情况是文中所说的从反面压制。要维护公共秩序，必须要有两种制裁，第一种制裁：针对违反公序良俗人的制裁；第二种制裁，是在第一种制裁失效时，对于没有应责维系公序良俗人的制裁，因为社会的每个人都是没有带警徽的警察。 所谓的大家就是由一个个”你“和”我“组成。如果你不会见义勇为，自然大家也不会见义勇为。这就进入了一个恶性循环。那么假如人人都愿意去挺身而出，那么结果自然相反。 而所谓的社会资本论就是社会良性循环下的产物。在一个大城市里，因为犯罪现象屡禁不绝，时而飞来横祸；哪怕是同一栋公寓，因为人们老死不相往来街坊领居彼此都不认识，那么大家对彼此都不放心，我相信每一对年轻的夫妇都不敢让幼龄子女随意出去玩耍。但是如果在一个乡亲氛围浓厚的村庄，街坊领居彼此都认识，自然不用担心小孩被拐的事情发生。而这其中的关键点就是人们彼此信任而产生的“社会资本”。 社会资本是一个人对环境的熟悉或心理上的安全感，也可能是一种对别人，对规章制度的信任。在一个社会资本充裕的环境里，人们一方面享受社会资本，一方面维护社会资本。相反在一个社会资本较少的环境下，没有多少资源可以利用，人们自然也不愿意去付出和投入，自然也不会有太多的社会资本。（写到这，我不禁发现，最近几章都有强调一个良心循环和恶心循环的差距，不管是第4章的经济循环呢还是这一章的信任循环，良性循环会降恶性循环的差距越拉越大）。 最后讲了充沛的社会资本的由来，列举了3点。1人少2环境小3重复交往。重中之重的是第3点重复交往。]]></content>
      <categories>
        <category>《解释的工具-生活中的经济学原理》</category>
      </categories>
      <tags>
        <tag>《解释的工具-生活中的经济学原理》</tag>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第六章-这种孩子，不养也罢]]></title>
    <url>%2F2017%2F05%2F16%2F6.%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86-----%E8%BF%99%E7%A7%8D%E5%AD%A9%E5%AD%90%EF%BC%8C%E4%B8%8D%E5%85%BB%E4%B9%9F%E7%BD%A2%2F</url>
    <content type="text"><![CDATA[《解释的工具-生活中的经济学原理》—–第六章-这种孩子，不养也罢这篇看完有点没看懂，不知道是不是因为自己代入感太弱不够，还是不能完全转变成经济学角度去理解，那就先粗略写个读后感吧。 文章开头先介绍了一个“经济租”的概念，在我的一开始的理解中其实也就是个人或者企业的品牌价值。总结成一句话凭借个人的天赋或者努力，创造出令人羡慕的经济租，引入观点—付出的成本和获得的收益的考量。然后严肃的将这个观点带入到了一种最特殊的伦常关系里—父母与孩子的亲情。父母与子女的关系一旦形成，对于双方来说收益是大于成本的。 文中给出的解释是：人在进化的过程里，为了繁衍自己的基因，会慢慢发展处一些工具上的安排，其中就包括实际的作为和思想上的配套措施。 然后文章建立在上述思想下，以朋友为教导员进行降维阐述。在离开父母后，邻居会慢慢成为好朋友。因为如果邻居之间关系不好，处理一些共同事物会变得特别麻烦，人们在这些因素的影响下，会有意或者无意识的去衡量这些利弊得失，然后“自然而然”的成为好朋友。（不过在中国国情下，邻居的概念因为房子的原因比较薄弱，感觉可以用来形容从工作走向生活的好朋友）。 最后引述到如何看待这种关系。文中引入了金刚经中“离相无往”的概念。不要让自己强羁绊在某个关系上，不然会可能会令自己渐失所倚，从而满腹惆怅。（文中有个观点倒是不错。离相：挣脱表面的执着。许多动作和事物本身并没有意义，所有的意义都是被填充和赋予的。） 写不下去了。这一章文章感觉有点晦涩，可能是因为触及到了人们所依赖的亲情，顾及底线，没有讲的很露骨；同时因为自己的身份原因，我也很不能理解其中的一些表述。力所不及。]]></content>
      <categories>
        <category>《解释的工具-生活中的经济学原理》</category>
      </categories>
      <tags>
        <tag>《解释的工具-生活中的经济学原理》</tag>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第五章-谁懂谁的心]]></title>
    <url>%2F2017%2F05%2F12%2F5.%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86-----%E8%B0%81%E6%87%82%E8%B0%81%E7%9A%84%E5%BF%83%EF%BC%88%E4%BF%A1%E6%81%AF%E9%97%AE%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[《解释的工具-生活中的经济学原理》—–第五章-谁懂谁的心由于自己身处互联网的大环境中，给我印象最深的还是“信息不对称”所带来的影响。 关于信息不对称也有好几个维度可以阐述。 1.信息交换。《囚徒困境》（官府抓了两个没有证据的两个江洋大盗，隔离在两个小房间，如果谁先招供承认就从轻发落，另外一人则受到严重处分，如果都不松口，则官府因为没有证据释放两个人。那么到底招还是不招呢？）。这个故事中信息的不对称体现在两人无法交换信息。如果两人有机会偷偷交换信息并在官府不知道的情况下，则两人都可以化险为夷。这让我想到许多间谍片中，在众人眼皮子地下，两人暗藏机锋的话语或者动作其实传递出价值千金的重要信息。 2.信息不对称的价值。互联网可以说是将信息不对称的价值几何倍的放大。以旅行产业链为例，价值几千的住宿和机票，可以通过某些途径花几百元可以获得。许多小公司ru大公司的羊毛（补贴）也能轻松年入上百万。而在caoz公众号中所说的，许多草根运营公司依靠自己独特的流量技巧生活可以说过的是非常滋润。 3.判断信息的能力。信息不对称必然会带给某一方价值中介公司，，但是如果每个人都抱着这样的想法，那么在人们生活也会越来越复杂。但是除非社会可以产生良心循环，否则我们本人也只能根据这些信息培养自己的判断力，进行斟酌取舍。我们平时会去固定的餐馆，水果店消费，也是根据之前信息交换产生的讯号，根据自己的判断力，找出对自己最有价值的地方。 4.信息的泛滥。当信息不足的时候，会有人以提供信息能力来获取报酬，托福机构，法律顾问，补习班都是这个例子，信息价值的提高往往是由于其稀缺性。但是在互联网的环境下，人们也许面对的是满船的鱼和虾，而怎么找出其中所藏的珍珠则是能力的体现。这也透露出，在信息过多的情况下，处理信息本身也是一个信息 问题。也许我们自己没有这个能力去筛选那么多鱼龙混杂的信息，不过我们可以依赖一些人帮我们去解读生活里的各种讯息，在已筛选信息的帮助下，依据自己的经验进行判断，找到自己最有价值的地方。这也体现出一个道理，成为独特理性信息的提供者，你就对别人产生了价值，那么你就有价值了！！！。]]></content>
      <categories>
        <category>《解释的工具-生活中的经济学原理》</category>
      </categories>
      <tags>
        <tag>《解释的工具-生活中的经济学原理》</tag>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第四章-对铜臭味的追求]]></title>
    <url>%2F2017%2F05%2F11%2F4.%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86-----%E5%AF%B9%E9%93%9C%E8%87%AD%E5%91%B3%E7%9A%84%E8%BF%BD%E6%B1%82%2F</url>
    <content type="text"><![CDATA[《解释的工具-生活中的经济学原理》—–对铜臭味的追求今天在有许多资本国家为榜样，并且资本技术也不是遥不可及，为这么这些落后地区却好像在时空的轨迹上静止不动，和其他的国家越行越远呢？ 落后地区的的大多数经济流动提现在某次交易上。交易双方多为萍水相逢，而且以后不会再碰到，这样子双方都希望在”本次交易”中获得好处，则卖家会巧舌如簧，把自家的商品吹得天花乱坠；买东西的人会不假辞色的挑三拣四，嫌东嫌西。双方会花各自的小聪明以及很长的时间里去计较得失。这种恶性循环一旦形成，商家不会想着改良质量去靠口碑取胜，所以几十上百年来所买卖的东西也没有什么大不同，更重要的是其对人性的摧残，大家变得虚浮狡诈，互相不信任。 这种令人感叹的“低度均衡”当然无法与西方先进社会日新月异，产生良性循环的“高度均衡”相提并论。 人与人之间的信任极大的促发了现代经济社会的形成，而金钱作为可以最大程度体现“信任”价值的物品，对经济社会的成长可谓功不可没。 这个故事告诉我们，人的聪明才智可以花在许多地方，有些时候，这些聪明才智花在“做虚功”—浪费在一些既没有功劳，也没有苦劳的用途上]]></content>
      <categories>
        <category>《解释的工具-生活中的经济学原理》</category>
      </categories>
      <tags>
        <tag>《解释的工具-生活中的经济学原理》</tag>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《腾讯传》读后感]]></title>
    <url>%2F2017%2F05%2F09%2F%E3%80%8A%E8%85%BE%E8%AE%AF%E4%BC%A0%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[《腾讯传》读后感首先感谢孙世豪借给我这本书阅读。 每一个人成功都是有他自己的优势的，我曾经不断的对比那些在今天社会上获得许多成就的人（互联网行业），发现每一个人在达到今天的成就时，前面都经历过许多困难，或沉淀了很久，终于在某个时机来临的时候爆发了出来。我也不断的安慰自己，你今天的不成功自己有没有沉淀过，如果有的话，那么不要心急，时间会证明你今天的一切是值得的。如果在最后你还没有成功，那么既然已经到了最后，也不重要了。 整部腾讯传的前半部是围绕马化腾和他的qq展开的。出身于深圳大学计算机系的专业，少年时期的马化腾可以说是第一批互联网人。在98年那个互联网刚开始起步的年代，毕业之后，他通过站长这个身份进入了互联网行业，认识了许多早期杰出的人，如今天创建网易的丁磊。在这种前沿的氛围下，身体中潮汕人的血性也让他在一家企业默默苦干两年之后决定自己创业，正式投入了互联网的大潮。 一个好汉三个帮。深圳大学的经历让他接触到了早期最好的合伙人。张志东，陈一丹，许晨晔，曾冬青，5人一个最简单的组合出现了，这5个人互相扶持不断成长，到今天已经快20年了，借助着初期创业产品的qq，成长为了互联网的一级。而在当时，98年可以说是中国互联网的元年，不只是腾讯的成立，马云，张朝阳等早期一位位互联网大佬都开始于这个年代 上面写的是个jb啊，那不是读后感，是有一本腾讯传的简单复述 每个人的成功都有他的先决条件，当然偶尔的个例不在讨论范围内。 (1)少年时期的马化腾就是深圳大学的编程高手，而他的合伙人更是进修过算法这块的硕士，所以说在产品诞生这块，他就比很多公司有先决优势。 (2)身处深圳这个中国的开放城市，也让他可以更快的接触到互联网相关的变化，早期的站长经历让他接触了许多互联网的人。而这些人中不乏后来的互联网大佬，在一个关注加学习他人的过程中，他们自己也成长起来。如果自己以后想要成长起来，一定要身处大环境中亲身去经历。 (3)早期的错位。在刚开始阶段，腾讯所赖以生存的收入并不是来自qq，而是短信收入。依靠传呼机和移动梦网的收入，不断的喂养的qq这头成长起来的怪兽。我在想如果没有前几年毫无顾忌的投入在qq运营服务上的这些钱，稍微有一点迟疑，那么当年的qq是否会因为使用感的下降而慢慢沉寂下去呢。 (4)不可或缺的运气。早期qq的用户并不受投资人的看好，加上没有没有特别好的营收渠道，账面上的金钱也逐渐见底。同时因为qq的用户不被大部分的投资人所看好，所以在2000年初故事崩盘带来的互联网寒冬到来之前，腾讯也因为金钱走到了生死存亡的关口。不过所幸他们当时的当机立断，在股市崩盘前互联网炒的最热的风口融到了一笔关键的钱，让他们可以在互联网寒冬来临的时候艰难的生存下来。虽然中间仍然存在了一些挫折，不过最终还是活了下来。 (5)底蕴的爆发。qq的用户早期多为年轻人，上亿的用户体量实在是个庞然大物，所以在qq秀，钻石体系等相关产品引入的时候，实实在在的点燃了年轻人喜欢突显自身个性却又因为缺少金钱无法在现实生活中表现的“怒火”。在投资人不被人看好的年轻用户，也因为这么多年的成长成为了庞大的消费者。所以说用户是需要人培养出来的，虽然摘果子的可能并不是你，比如团购，外卖等等。但是如果你能摘到自己培养的果子，那么成功自然而来，现在互联网中双极的AT无疑都是典型例子，一个陪伴了多年的年轻用户成长到今天已经是主力消费者了，一个靠着支付这道门槛建起了沉沉的护城河。 (6)细节的逆袭。早期不断有人说腾讯是一家抄袭公司，泡泡堂，跑跑卡丁车，偷菜等火爆一时的游戏或互联网现象级的产品，都有腾讯的身影。我当年也是偏执的认为腾讯依靠庞大的qq用户不断的营销的自己的产品，不过书中则从产品的角度去阐述了其“抄袭”的成功，腾讯不只是一家只会抄袭的公司。以qq堂举例，一开始的模仿和创新是极其失败的，但是产品人员在吸收教训之后则不断更新迭代，最终成功在《泡泡堂》运营3年后遭遇到老化问题时，成功逆袭。qq堂这个产品也反映出了早年腾讯的特点：紧盯市场热点，快速跟进优化，利用自己的流量优势整体替代。但是绝对不能忽视的一点是不断迭代，不断优化和创新的能力 (7)强调优势，借力打力。聪明的人善于利用自己的优势，腾讯最大的优势qq上亿的用户。出击棋牌游戏领域时，凭着IM客户端的优势，通过显示好友在玩什么游戏进行跟踪的功能，一举打败了联众棋牌。其后的qq秀以及qq飞车等代表，无一不是腾讯对于流量和用户天才般的使用。借助已有优势，发挥更大的力量，应该是每一个聪明的人应该做的。商业不是过家家，各个领域你死我活，你要明白自己的优势，才能更好的生存下去。 (8)看不见的敌人。最危险的敌人不在的敌对名单列表。这句话是在腾讯与51的战争中得出来的经验。51就是郑志昊在一次走入网吧中才观察到这个隐藏的敌人，从而开始了一场极其关键的长达1年多的拉锯战。这场战争既完善了自身产品的一些缺陷，也保证了自己产品在web端的垄断地位。你要明白最大的危险可能来源于你看不见的角落，不能被明面上的光鲜所遮蔽。 (9)成功后的开放。经历过2010年与360的战争，全民公敌的腾讯终于认识到自己在行业中的形象，随后开放半年向全社会获取意见的行动，成就了今天的腾讯。今天的腾讯市值已经是那一年的近6倍了，在增产率上已经跑赢了房价（当年买个腾讯股票真是不要赚的太稳啊）。]]></content>
      <categories>
        <category>explainTools</category>
      </categories>
      <tags>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《激荡三十年》读后感]]></title>
    <url>%2F2017%2F03%2F29%2F%E3%80%8A%E6%BF%80%E8%8D%A1%E4%B8%89%E5%8D%81%E5%B9%B4%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[第一次想看这本书的时候，是抱着“以史为鉴，可以知兴替”的想法，想去看看改革开放三十年到底是一个怎样激情的时期。 翻开第一章，就有一种历史的画卷在我面前满满铺开的感觉，站在今天看那三十年，到底经历了多少的沉淀啊，那段坎坷的时期，他们是怎么过来的啊，又是怎么披荆斩棘冲出重围的，那么我应该从这三十年学到些什么呢？ 不过当读完之后，却有一种说不出来的惆怅感。如今我身处2017年，书中当年介绍的一些名不见经传的小公司也已经成长为了世界级企业，似乎也是对那三十年进行了一个满意的结尾。但是不能忘怀的是那些曾经从泥尘走向山顶，却因为种种原因而晚年凄凉，哎，一声长叹。 翻来书本，先映入眼帘的是1978年贫穷的场景，破破烂烂的建筑物，国企里麻木的工人，国家的计划经济仍然严格管控着人民的生活。正如小说中一样，时代走到了这一步，总需要有人讲中国带出这个泥潭。当选为新一任领导人的邓小平爷爷开始尝试改革，率先尝试的高考制度，就成功为之后几年企业改革埋下了火苗，许许多多在历史留下浓重一笔的人物开始有资格进入大学开始获取知识。星星之火，可以燎原！ 当然也还有一些仍然在生活中生存的人们，如王石，牛根生仍然在底层漂泊，但是从今天的成就来看，他们都是那个经历过那个时代成功的人物。 接下去几年人们明里暗里偷偷的制度改革开始渐渐浮出水面，最出名的自然是冒天下之大不韪的小岗村的生死状，今天被称为天下第一村的华西村，真的很佩服当年这些人，有这种魄力敢率先反抗国家的制度。 在民企还没有出生的年代，承担了国家主要经济发展的国企则实在是令人失望，“铁饭碗”和“继承”的制度让大家失去了活力。新制度中的奖励政策对于那个年代的影响真是不言而喻。忽然想到了一句话，只要你努力了那么一点点，你就可以超越一大份人，毫无疑问，在那个年代，一点点小制度的改革都激发了巨大的影响效益，成功诞生了一大批的改革英雄。成功不是一蹴而就的，虽然之后仍然经历里许多波折，不过一个好的开头已经是很让人感动了。 不过这几年中让人总有些许失望的地方，国家对于国企的偏爱实实在在是扼杀了许多民企的发展，典型如“双轨制”的诞生，简直是在加深他们好逸恶劳的恶习，导致在今天已经是正常商业规则的“低买高卖”，则是是谁碰谁死的雷区，“投机倒把”的大棍之下，不知道扑灭了多少企业家，多少人因为这个含冤坐牢甚至失去生命。无奈的是，总有许多先辈为了制度的改革付出了太多太多。 各地地区萌芽的家庭企业制度因为影响到了国企的效益，遭到不断的讨论和论证，小火苗被不断的扑灭和打击，一些在早期获取到利益的店主甚至遭到了牢狱之灾的惩罚，我今天在想，如果没有那些打击，在这些民营企业的影响下，国企的成功改革是不是会更快一些，在今天已经受到尊重的”竞争”在当年可以牢饭啊。 不过中国幸运的是仍然有许多支持改革的上层人物，记得广东和福建书记作为一方封疆大佬尽自己最大的努力坚持了改革，虽然自身付出了惨痛的代价，但今天却可以明显看出效果，比如今日之广东和受到波折的福建的对比。 在本书中有一个始终让人难易忽略的群体，就是温州对于民企改革的影响，可以说他们是改革探索的先锋队，今天的浙江经济已经完全离不开民企了。温州作为时时触碰了国家的警戒线的群体，不断的遭受的打击，典型如“温州八大王”事件，不过他们也享受到了改革最大的好处，0203年千亿资金的温州炒房团可以说是最早享受到了房地产红利的人了吧。 说到房地产，真的是很难想象这个影响至今的政策是由朱镕基总理提出来的，目的是为了化解被称为“笼中老虎”的人民储蓄。不过想想也是，政府高层永远是为了稳定，为了自己保护自己阶级做出保护措施。朱镕基总理作为对经济改革影响仅次于邓小平爷爷的人物，做出的贡献无法估量，不过不知道他当年有没有想到98你那的房地产政策重启的影响竟然可以持续到现在，甚至说还将继续影响下去。对哦，日本房地产的泡沫已经发生，这么说来，当年他想到的可能比我今天想到的还多。不过如果每个国家领导人真的都有朱总理那种魄力的话，可能会崩盘，但是也有可能会变得更好。朱总理曾说“不管前面是万丈深渊还是地雷阵，我都将一往无前，义无反顾，鞠躬尽瘁，死而后已”，他当得起自己说的话。 忽然又想到最痛心的是95年依靠“价格战”成功打败外企的企业加们，当李东生高喊那句“与外国兵团的较量，TCL要作为产业报国的敢死队，我李东生就是’敢死队长’”的那句话时，企业家振奋人心，民众热血沸腾，直到今天，我依然感受到了书中那种激昂的感觉。遗憾的是，他们成功了，他们也失败了。成功获取到市场份额的他们没有想到利用技术巩固自己的品牌优势，而是用了许多投机取巧的方法去蒙蔽顾客，希望可以继续抢占市场份额。可惜的是人们不是傻瓜，外企们也不是傻瓜，几年后终于自食苦果，让人痛心，痛失大好先手；其中还包括了今天仍然受到尊重的海尔。不过也正如企业家自身所说，时代和经历的受限，中国企业史没有对应的经验参考，才会给了这次重大挫折，不过今后也许不会这样了吧。 其实还有一个感悟如前面所说的，也许往后100年来看今天，其实机会还有很多，远远不是大家所想的已经被各种垄断了，正如08年金融危机的时候，都说美国带领的信息时代已经将所有互联网应用都已经发明殆尽了。但是事实呢，进入了移动互联网时代的我们，哪里是9年前他们所敢想象的，我们今后还有看得见vr，看的见人工智能，还有许多我目前看不见的。亲爱的林智翔，机会还有很多，你要记住不要被自己局限的眼光所耽误了啊。 正如上句所说，中国人其实还没有诞生属于自己的企业管理思想，80年代，90年代大多数的管理经验其实都是借鉴了日本的管理经验，我相信经过这快40年的发展，国人的管理思想应该不远了吧。12345678ganttdateFormat YYYY-MM-DDsection S1T1: 2014-01-01, 9dsection S2T2: 2014-01-11, 9dsection S3T3: 2014-01-02, 9d]]></content>
      <categories>
        <category>explainTools</category>
      </categories>
      <tags>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从输入URL到浏览器显示页面发生了什么（前端篇）]]></title>
    <url>%2F2017%2F03%2F21%2F%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%88%E5%89%8D%E7%AB%AF%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[为什么要强调前端篇，因为看到有一部分技术文章更是讲到了硬件方面的知识，因为自己目前能力有限，所以更着重于前端这一块。 到现在也看了许多的技术文章了，今天第一次下笔写文章，主要是为了加深自己这方面的印象，二来指不定在自己写的过程中会遇到一些自己以前没有注意过的新问题。 当用户在网址栏输入信息的时候，当用户输入url时，浏览器会从本地地址中调取缓存的历史记录，来减少用户需要输入的文字。还有一种情况是输入非url时，类似于chrome浏览器，它会将你输入的字符进行转换为非ASCII码的Unicode字符作为后缀添加在url后面进行搜索。 由于用户更擅于记住域名和主机名，而计算机更擅于处理一组纯数字的IP地址，这时DNS服务则应运而生。DNS协议提供通过域名查找IP地址或逆向IP地址反查找域名的服务。 当用户确认输入好之后信息后，点击回车确认，浏览器首先会从本地DNS缓存（chrome://net-internals/#dns）中读取当前网址所对应的域名；如果缓存中没有找到，则去本机中的gethostbyname库函数进行查询（不同操作系统中的函数不同），会在本机host文件中查看是否有对应的域名；如果gethostbyname库没有找到，则会向本地DNS服务器发一条DNS查询请求，通常是在缓存在本地路由器或运营商的服务器；如果还没有找到，则会一直向上寻找到最顶部全球13台dns根域名服务，然后依次返回到本机。（好像亚洲唯一一台在日本，不知道是不是几年第一个浏览器页面在日本诞生，瞎猜猜） 当用户获得域名之后，主机开始发送TCP/IP请求，即经典的三次握手。 第一次握手。第一次向服务器发送码SYN=1，随机产生一个seqnumber(sequence number)码(1234567)，表示请求建立连接； 第二次握手。当服务器接收到确认联机的信息后，向主机发送一个ACKnumber=(主机的seqnumber+1)，SYN(synchorinize)=1，ACK(acknowledgment)=1，并随机产生一个seqnumber=(7654321)的包。 第三次握手。主机会检查收到acknumber是否正确，即是否为第一次发送的seqnumber+1，一级ACK码是否为1，主机如果收到SYN和ACK都为1则表示确认连接。 完成三次握手，主机开始与服务器发送数据。如果在这三次握手中任何一个环节出了问题，TCP协议会再次以相同的顺序发送数据包。当然除了3次握手，TCP协议还有其他各种手段保证通信的可靠性。 这里涉及到一个知识点，就是为什么要三次而不是两次握手。看过几篇文章的表述，用自己理解的语言来说下。关键是在于第三次请求，假设第三次请求因为某些原因没有及时发送到服务端，而服务端再过了一段时间之后才获取到这个延迟请求，会将此误认为一个新的连接请求，但实际上这并不是一个新的运输连接。结果服务器苦苦等着客户端不可能发送过的数据，从而浪费了许多服务器资源。而如果有了三次握手，服务端如果不收到第三次请求，就知道客户端不会发送请求。 当文件传输完毕后，浏览器开始渲染页面。这里浏览器有一个渲染引擎，即我们常说的各种浏览器内核，比如Safari的webkit，chrome的Blink，IE的edge，另外一个则是js引擎，例如有chrome的V8引擎，IE的EdgeJScript，FireFox的SpiderMonkey(firefox的第一款引擎世界的第一款引擎，js之父所写)。 服务器和客户端都可以发出中断请求 服务器发出中断请求情况当一个请求发完之后，则开始了四次挥手。第一次挥手：由服务器先发送了一个FIN码,随机产生一个序号i，用来关闭主动方到被动方的传输，告诉主机我不会再给你发送数据了(当然在FIN码发送之前发出去的数据，如果没有收到对应的ACK确认报文，则依然会重发这些数据)。此时主机仍然在可以接受数据 第二次挥手：主机收到FIN码之后，发出一个ACK给服务器，确认序号为收到序号i+1(与SYN相同，一个FIN占用一个序号) 第三次挥手：被动关闭方发送一个FIN码，用来关闭被动方和主动方的数据连接，也就是告诉主动关闭方，我的数据已经发送完了，不会再给你主动发送数据了。 第四次挥手：主动关闭方收到FIN码之后，发送一个ACK给被动关闭方，确认序号为收到序号i+1。至此，完成4次挥手 用我自己的理解来说就是， 前两次是互相确认没有数据传输了（1.a告诉b没有数据给你；2.b知道a没数据给自己了;）， 后两次是确认不需要连接了（3.a告诉b关闭连接了；4.b知道a关闭连接了，a接受到反馈知道b也关闭连接了）。 客户端发出中断请求情况(1) 客户端发出一个FIN码，产生一个序号i用来关闭主动到被动方的数据连接,(2) 服务器收到一个FIN码后，它发回一个ACK，确认序号为收到的序号i+1，(3) 服务器关闭了被动关闭方和主动关闭方的数据连接，并发送一个FIN码给主动关闭方(4) 客户端收到确认的ACK报文后，并将确认序号设置为收到序号i+1 这里有一个问题在于为什么挥手比牵手多了一次动作。我的理解就是多了一个关闭连接的操作。互相不发送数据是半关闭，互相关闭连接是真正关闭。 页面渲染首先开始根据html文件开始构建最初的DOM树，然后根据获取的css文件的样式表，形成CSSOM，这时候结合dom和CSSOM，创建出来一颗渲染树。在渲染树中，每一个字符串都是一个独立的渲染节点，每一个渲染节点都是经过计算的，叫做布局(“layout”)。如果此时获取到js文件并开始执行时，渲染过程则会停止（渲染和执行js不能同时执行）。在js执行过程中，会有相关代码会导致浏览器的重绘(repaint)和回流(reflow)，这是首屏渲染应该注意的地方。 引起回流的js代码众所周知，现在许多提高页面性能的方法都是有一条都是减少dom的操作，而dom操作影响的直接结果一般都是说dom的变化引起了dom结构的改变，导致了页面的重排，这个引起的过程可以叫做回流。引起回流的情况有许多，列几项典型举例下： dom元素本身的大小改变(原因有width,内容,margin,padding,等等的变化)影响了页面结构，直接导致其下面所有元素的重排。 获取特殊属性如offsetLeft(家族)，scrollLeft(家族),clientHeight(家族)，padding等(原因在于浏览器为了获得正确的值，会强制触发一次重排)，所以应用临时变量缓存起来 添加和删除DOM元素 页面窗口的变化，也就是resize 常见的优化方法网上也是一搜一大堆，不过大多数方法核心点是在于尽可能减少直接影响的次数，列几项典型举例下： dom元素脱离文档流，比如absolute什么的 将多次dom增删实现存储虚拟dom中，然后最后一次直接操作dom树；或者多个样式合在一个class变为一次操作。 类似于上条，先display:none隐藏dom元素操作，再出现，只操作两次 存储会获取会引起重排的属性，缓存到一个变量中 幸运的是现代浏览器引擎有时候会积累足够的变化，或一定时间，或一个线程结束才发生一次变化。不过好的规范应该在编写代码时就注意到。 咦，好像写完了，感觉不会那么少啊，是不是我还漏了很多和前端有关的东西忘记写啊]]></content>
      <tags>
        <tag>技术文章</tag>
        <tag>http</tag>
      </tags>
  </entry>
</search>
