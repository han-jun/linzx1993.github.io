<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, linzx" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="linzx linzhixiang 林智翔 linzx1993@gmail.com linzx1993">
<meta property="og:type" content="website">
<meta property="og:title" content="linzx">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="linzx">
<meta property="og:description" content="linzx linzhixiang 林智翔 linzx1993@gmail.com linzx1993">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="linzx">
<meta name="twitter:description" content="linzx linzhixiang 林智翔 linzx1993@gmail.com linzx1993">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>linzx</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?93e1e7523d9fccc42d9201ace7ca982a";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>











  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">linzx</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/24/理解jquery的深拷贝源码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="linzx">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/24/理解jquery的深拷贝源码/" itemprop="url">理解jquery的深拷贝</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-24T23:47:44+08:00">
                2017-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/08/24/理解jquery的深拷贝源码/" class="leancloud_visitors" data-flag-title="理解jquery的深拷贝">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  1,855
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  7
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>好像自从使用框架之后，对jquery的依赖越来越低了，其好像已经慢慢作为一个工具库的存在了。新项目商量之下，为了减小文件大小，干脆直接不用jquer2，对于一些需要的工具函数直接从jquery提取到一个自己写的工具文件tool.js中。在提取的过程中，也慢慢理解了jquery一些工具函数的源码</p>
</blockquote>
<p>深拷贝和浅拷贝的使用场景不同，并没有好坏之分，像对一些基本数据类型，直接可以使用浅拷贝对处理数据。但是对于基本引用类型如嵌套对象，数组（包含着对象的数组），那么就需要使用到深拷贝了。</p>
<blockquote>
<p>不想看前面深浅拷贝对比的，可以直接拉到第二章看jquery源码实现</p>
</blockquote>
<hr>
<h4 id="1-浅拷贝解析"><a href="#1-浅拷贝解析" class="headerlink" title="1.浅拷贝解析"></a>1.浅拷贝解析</h4><p>原生js也有一些提供拷贝的函数，比如数组的Array.slice(0),Array.concat()，对象的Object.create(),Object.assign()等等，但是都是浅拷贝，遇到二维数组，嵌套对象就通通失败了（以前不懂的时候，真的被坑的不要不要的啊）。</p>
<p>比如下面这个例子，都是在只有基本数据类型的情况下，使用浅拷贝就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">let arr = [1,2,34,5,67,8,9];</div><div class="line">let cloneArr = arr.slice(4);</div><div class="line">console.log(cloneArr);  //  [67, 8, 9]</div><div class="line"></div><div class="line">cloneArr[0] = 100;  //  修改cloneArr</div><div class="line">console.log(arr);   //  [1,2,34,5,67,8,9],修改cloneArr不影响原数组arr</div><div class="line"></div><div class="line">----------------</div><div class="line"></div><div class="line">let obj = &#123;a : 1,b : 2,c : 3,&#125;;</div><div class="line">let cloneObj = Object.assign(&#123;&#125;,obj);// 将拷贝的属性值拷贝到目标对象，然后返回目标对象</div><div class="line">console.log(cloneObj); //   cloneObj = &#123;a : 1,b : 2,c : 3,&#125;;</div><div class="line"></div><div class="line">cloneObj.a = 444;   //修改对象</div><div class="line">console.log(obj);   //  obj = &#123;a : 1,b : 2,c : 3,&#125;; 修改拷贝对象不影响源对象</div></pre></td></tr></table></figure></p>
<p>但是如果以上例子将基本数据类型换成引用类型Object和Array呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">let arr = [1,2,&#123;a : 3&#125;,&#123;b : 4&#125;,5];</div><div class="line">let cloneArr = arr.slice(2);</div><div class="line">console.log(cloneArr);  //  [&#123;a : 3&#125;,&#123;b : 4&#125;,5];</div><div class="line"></div><div class="line">cloneArr[0].a = 100;  //  修改cloneArr</div><div class="line">console.log(arr);   //  [1,2,&#123;a : 100&#125;,&#123;b : 4&#125;,5],修改cloneArr影响原数组arr</div><div class="line"></div><div class="line">----------------</div><div class="line"></div><div class="line">let obj = &#123;a : &#123;aa : 1&#125;,b : &#123;bb : 2&#125;,c : 3,&#125;;</div><div class="line">let cloneObj = Object.assign(&#123;&#125;,obj);// 将拷贝的属性值拷贝到目标对象，然后返回目标对象</div><div class="line">console.log(cloneObj); //   cloneObj = &#123;a : &#123;aa : 1&#125;,b : &#123;bb : 2&#125;,c : 3,&#125;;</div><div class="line"></div><div class="line">cloneObj.a.aa = 100;   //修改对象</div><div class="line">console.log(obj);   //  obj = &#123;a : &#123;aa : 100&#125;,b : &#123;bb : 2&#125;,c : 3,&#125;; 修改拷贝对象影响到了源对象</div></pre></td></tr></table></figure>
<p>为什么会这样子，原因其实也不复杂。js内存分为栈内存和堆内存。所有的基本数据类型都是存储在栈内存中，而引用类型则是存储在堆内存中，提供了一个地址放在了栈内存中。当我们要获取引用类型的值时，先从栈内存获得地址，再根据地址去堆内存中获得值。因此也叫按引用访问。</p>
<blockquote>
<p>(去网上浅拷贝了一张图片，因为拷贝了一个图片地址)<br><img src="http://img.blog.csdn.net/20141212220233511?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGRkMTk5MTA1MDU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="去网上浅拷贝了一张图片，拷贝了一个图片地址"></p>
</blockquote>
<p>而我们上面例子中，每个数组和对象每个属性存储的引用类型obj其实是个地址，我们只是简单的拷贝了属性值，其实就是拷贝了一个地址。所以我们在新对象里进行修改时，由于是通过同一个地址修改了值。因为和原对象共用了一个地址，所以自然就修改了原对象的值了。</p>
<h4 id="2-深拷贝解析"><a href="#2-深拷贝解析" class="headerlink" title="2.深拷贝解析"></a>2.深拷贝解析</h4><p>前面解析了浅拷贝。因为我们项目对大型数据处理占据了大头，其中不可避免的会经常用到深拷贝这块。那么深拷贝是怎么实现的。</p>
<p>其实也很简单，就是根据地址找到你堆内存中的值，不断递归深入拷贝下去，直到为基本数据类型为止，接下去就贴上深拷贝代码。</p>
<p>在讲jquey前，还有一个很暴力的方式<strong>JSON.parse()和JSON.stringify()</strong>;缺点是</p>
<ul>
<li>数据不能包含函数。</li>
<li>如果某个对象属性值为null，会形成一个对象的闭环<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;</div><div class="line">    a: 1,</div><div class="line">    b: 2,</div><div class="line">	c: [1,2,3],</div><div class="line">    d: function() &#123; </div><div class="line">        console.log(&quot;asdfghj&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">let result1 = JSON.stringify(target);</div><div class="line">console.log(result1); //    输出结果为&quot;&#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:[1,2,3]&#125;&quot;，函数直接没了</div><div class="line"></div><div class="line">const obj = &#123;</div><div class="line">  foo: &#123;</div><div class="line">    name: &apos;foo&apos;,</div><div class="line">    bar: &#123;</div><div class="line">      name: &apos;bar&apos;</div><div class="line">      baz: &#123;</div><div class="line">        name: &apos;baz&apos;,</div><div class="line">        aChild: null // 待会将指向obj.bar</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">obj.foo.bar.baz.aChild = obj.foo // foo-&gt;bar-&gt;baz-&gt;aChild-&gt;foo形成环</div><div class="line">JSON.stringify(obj) // =&gt; TypeError: Converting circular personucture to JSON</div></pre></td></tr></table></figure>
</li>
</ul>
<p>好了，最后贴上jquery深拷贝的代码和自己一些理解的注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">$.fn.extend = function () &#123;</div><div class="line">    //jquery喜欢在初始定义好所有的变量</div><div class="line">    let options,//  被拷贝的对象</div><div class="line">    	name,// 遍历时的属性</div><div class="line">    	src,// 返回对象本身的属性值</div><div class="line">    	copy,// 需要拷贝的内容</div><div class="line">    	copyIsArray,//  判断是否为数组</div><div class="line">    	clone,// 返回拷贝的内容</div><div class="line">    	target = arguments[0] || &#123;&#125;,</div><div class="line">    	i = 1,</div><div class="line">    	length = arguments.length,</div><div class="line">    	deep = false;// 默认为浅拷贝</div><div class="line">    	</div><div class="line">    //target 是传入的第一个参数,表示是否要深递归</div><div class="line">    if(typeof target === &apos;boolean&apos;)&#123;</div><div class="line">    	deep = target;</div><div class="line">    	//既然为boolean，则此处初始化target为第二个参数或者空对象</div><div class="line">    	target = arguments[i] || &#123;&#125;;</div><div class="line">    	// 如果传了类型为 boolean 的第一个参数，i 则从 2 开始</div><div class="line">    	i ++</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //如果传入的第一个参数不是对象或者其他，初始化为一个空对象</div><div class="line">    if(typeof target !== &apos;object&apos; &amp;&amp; $.isFunction(target))&#123;</div><div class="line">    	target = &#123;&#125;;</div><div class="line">    &#125;</div><div class="line">    //如果只传入了一个参数，表示是jquery静态方法，直接返回自身</div><div class="line">    if(i === length)&#123;</div><div class="line">    	target = this;</div><div class="line">    	i --;</div><div class="line">    &#125;</div><div class="line">    for(; i &lt; length; i ++)&#123;</div><div class="line">    	if((options = arguments[i]) !== null )&#123;</div><div class="line">            for( name in options)&#123;</div><div class="line">            	src = target[name];//获得源对象的值</div><div class="line">            	copy = options[name];//获得要拷贝对象的值</div><div class="line">            	//说是为了避免无限循环，例如 extend(true, target, &#123;&apos;target&apos;:target&#125;);</div><div class="line">            	if(target === copy) continue;</div><div class="line">            	//如果是数据正确，且是一个纯粹的对象（纯粹的对象指的是 通过 &quot;&#123;&#125;&quot; 或者 &quot;new Object&quot; 创建的）或者是一个数组的话</div><div class="line">            	if(deep &amp;&amp; copy &amp;&amp; ($.isPlainObject(copy) || (copyIsArray = Array.isArray(copy))))&#123;</div><div class="line">                    //如果是一个数组的话</div><div class="line">                    if(copyIsArray)&#123;</div><div class="line">                        copyIsArray = false;</div><div class="line">                        clone = src &amp;&amp; Array.isArray(src) ? src : [];//判断源对象是不是数组，如果不是，直接变为空数组，拷贝属性高优先原则</div><div class="line">                    &#125; else &#123;</div><div class="line">                        clone = src &amp;&amp; $.isPlainObject(src) ? src : &#123;&#125;;//判断原对象属性是否有值，如果有的话，直接返回原值，否则新建一个空对象</div><div class="line">                    &#125;</div><div class="line">                    //继续深拷贝下去</div><div class="line">                    target[name] = $.extend(deep,clone,copy);</div><div class="line">            	&#125;else if(copy !== undefined)&#123;</div><div class="line">                    //如果不为空，则不是需要深拷贝的数据和对象，而是string,data,boolean等等，可以直接赋值</div><div class="line">                    target[name] = copy;</div><div class="line">            	&#125;</div><div class="line">            &#125;</div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line">    // 返回新的拷贝完的对象</div><div class="line">    return target;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在看上段代码中，又发现了几个好方法在业务中会用到的，可以让代码更严谨<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">//判断数据类型</div><div class="line">//判断是否为纯正的数据对象</div><div class="line">isPlainObject: function( obj ) &#123;</div><div class="line">    //如果数据不正确，不是对象类型，或者是dom对象，window对象，则直接返回false</div><div class="line">    if ( !obj || jQuery.type(obj) !== &quot;object&quot; || obj.nodeType || jQuery.isWindow( obj ) ) &#123;</div><div class="line">    	return false;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //这段代码是为了兼容IE89存在的，查看是否有constructor属性，如果没有必然是数据对象</div><div class="line">    try &#123;</div><div class="line">    	if ( obj.constructor &amp;&amp;</div><div class="line">            !core_hasOwn.call(obj, &quot;constructor&quot;) &amp;&amp;</div><div class="line">            !core_hasOwn.call(obj.constructor.prototype, &quot;isPrototypeOf&quot;) ) &#123;</div><div class="line">            return false;</div><div class="line">    	&#125;</div><div class="line">    &#125; catch ( e ) &#123;</div><div class="line">    	return false;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //对象中key的顺序会将自身属性排在最前面遍历，如果最后一个还是自身属性，则必然所有属性都是自己的  </div><div class="line">    var key;</div><div class="line">    for ( key in obj ) &#123;&#125;</div><div class="line">    </div><div class="line">    return key === undefined || core_hasOwn.call( obj, key );</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<p>以上基本就是jquery.extend代码的解析了。extend是jquery中一个极其重要的方法，jquery本身就用它扩展了许多静态方法和实例方法</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/20/promise源码解析（译）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="linzx">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/promise源码解析（译）/" itemprop="url">promise源码解析（译）</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T23:47:44+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/08/20/promise源码解析（译）/" class="leancloud_visitors" data-flag-title="promise源码解析（译）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  4,582
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  18
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>最新项目中有用promise几个api，对代码结构看起来的确很爽。然后想着去网上找了几篇promise库源码解析的文章。但是看了几篇，感觉还是不能够很理解，然后看到一篇翻译文章有说道q.js库的作者有对promise实现的递进讲解，看了一下，还不错，</p>
</blockquote>
<p>Q.js作者源码分析：<a href="https://github.com/kriskowal/q/tree/v1/design" target="_blank" rel="external">Q.js作者promise递进讲解实现</a></p>
<p><a href="http://div.io/topic/1351" target="_blank" rel="external">网上找的promise源码翻译</a>。文章有些地方翻译的很好，但是对比原文发现少了一些内容，所以读起来很不顺畅。所以自己根据原文也翻译了一遍。对了，本文适合用过promise的人阅读。如果你还没有接触过。可以右转<a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="external">阮一峰的promise讲解</a></p>
<hr>
<h4 id="一、极简版异步回调"><a href="#一、极简版异步回调" class="headerlink" title="一、极简版异步回调"></a>一、极简版异步回调</h4><p>假如你正在写一个函数不立即返回值函数，需要等待几秒钟后才返回执行结果，你会怎么写呢？思考几秒钟。</p>
<p>最简单的做法自然是写一个回调函数依靠定时器来返回值，比如下面这个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var oneOneSecondLater = function (callback) &#123;</div><div class="line">    setTimeout(function () &#123;</div><div class="line">        callback(1);</div><div class="line">    &#125;, 1000);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这是一个很简单解决问题的方法，但是还有改进的地方，比如能够添加代码执行错误时给出提示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var maybeOneOneSecondLater = function (callback, errback) &#123;</div><div class="line">    setTimeout(function () &#123;</div><div class="line">        //进行判断情况，是执行成功的回调，还是执行错误的回调</div><div class="line">        if (Math.random() &lt; .5) &#123;</div><div class="line">            callback(1);</div><div class="line">        &#125; else &#123;</div><div class="line">            errback(new Error(&quot;Can&apos;t provide one.&quot;));</div><div class="line">        &#125;</div><div class="line">    &#125;, 1000);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>一般的做法是提供一个能同时返回值并且能抛出错误的工具。上面这个例子则演示同时提供回调和错误处理。但是这种写法实在是太定制化了，并不好。</p>
<h4 id="二、Promise基本雏形设计"><a href="#二、Promise基本雏形设计" class="headerlink" title="二、Promise基本雏形设计"></a>二、Promise基本雏形设计</h4><p>所以考虑到大多数的情况，代替最简单的返回值和抛出异常，我们更希望函数通常会返回一个对象用来表示最后执行成功或者失败的结果，而这个返回的对象就是<strong>promise</strong>。从名字上理解，promise表示承诺，那么最终这个<strong>promise</strong>（承诺）是要被<strong>resolve</strong>（履行，执行）掉的。</p>
<p>接下去我们开始迭代设计promise。我们先设计一个具有“then”方法的promise模型，通过“then”方法，我们能注册回调函数并且延迟执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var maybeOneOneSecondLater = function () &#123;</div><div class="line">    var callback;</div><div class="line">    setTimeout(function () &#123;</div><div class="line">        callback(1);</div><div class="line">    &#125;, 1000);</div><div class="line">    return &#123;</div><div class="line">        then: function (_callback) &#123;</div><div class="line">            callback = _callback;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">maybeOneOneSecondLater().then(callback1);</div></pre></td></tr></table></figure>
<p>代码写好了。但是大家仔细观察发现该方案仍然还有两个缺点</p>
<ul>
<li>一是现在方案只能执行一个添加的回调函数。最好的做法是每一个通过then添加进来的回调都能被通知到然后顺序执行。</li>
<li>二是如果这个回调函数是在promise创建好1s之后通过then添加进去，它将无法被调用。</li>
</ul>
<blockquote>
<p><strong>敲黑板，注意注意，接下去开始慢慢搭建promise了。</strong></p>
</blockquote>
<p>正常情况下，我们希望可以接收任何数量的回调，且不管是否超时，仍然可以继续注册回调。为了实现这些，我们将创建一个包含两个功能的<strong>promise对象</strong>。</p>
<p>我们暂时设计了一个defer对象，他的返回值一个包含两部分的对象（这个对象就是<strong>promise</strong>），一个用来注册观察者（就是”then方法添加回调），一个用来通知所有的观察者执行代码（就是resolve去执行之前添加的所有回调）。</p>
<p>当<strong>promise</strong>没有被<strong>resolve</strong>之前，所有回调函数会存储在一个”pengding”的数组中。</p>
<p>当<strong>promise</strong>被<strong>resolve</strong>之后，立即执行之前存储的所有回调函数，当回调函数全部执行完毕之后，我们将根据”pengding”来区分状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">let defer = () =&gt; &#123;</div><div class="line">    let pending = [],value;</div><div class="line">    return &#123;</div><div class="line">        resolve(_value)&#123;</div><div class="line">            value = _value</div><div class="line">            for(let i = 0;i &lt; pending.length; i++)&#123;</div><div class="line">                pending[i](value)</div><div class="line">            &#125;</div><div class="line">            pending = undefined;</div><div class="line">        &#125;,</div><div class="line">        then(_callback)&#123;</div><div class="line">            if(pending)&#123;</div><div class="line">                pending.push(_callback)</div><div class="line">            &#125;else&#123;</div><div class="line">                _callback();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let oneOneSecondLater = () =&gt; &#123;</div><div class="line">    let result = defer();</div><div class="line">    setTimeout(()=&gt; &#123;</div><div class="line">        result.resolve(1);</div><div class="line">    &#125;, 1000);</div><div class="line">    return result;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">oneOneSecondLater().then(callback);</div></pre></td></tr></table></figure>
<p>这开始的第一步很关键啊，因为此时我们已经可以做到</p>
<ol>
<li>可以任意时间添加任意多的回调;</li>
<li>可以人为决定什么时候resolve;</li>
<li>当promise被resolve之后，还可以添加回调，只不过此时立即就执行了</li>
</ol>
<p>但是还有一些问题，比如</p>
<ol>
<li>defer可以被resolve执行多次,我们并没有给出一个错误的提示。而且事实上为了避免恶意或者无意的不断去resolve，我们仅允许第一次调用可以通知回调并执行。</li>
<li>添加回调只能通过defer.then添加，不能链式调用,即defer.then(callback).then(callback)</li>
</ol>
<p>那么接下来我们先修正第一个问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">let defer = () =&gt; &#123;</div><div class="line">    let pending = [],value</div><div class="line">    return &#123;</div><div class="line">        resolve(_value)&#123;</div><div class="line">            if(pending)&#123;</div><div class="line">                value = _value</div><div class="line">                for(let i = 0;i &lt; pending.length; i++)&#123;</div><div class="line">                    pending[i](value)</div><div class="line">                &#125;</div><div class="line">                pending = undefined;</div><div class="line">            &#125;else&#123;</div><div class="line">                throw new Error(&quot;A promise can only be resolved once.&quot;)</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        then(_callback)&#123;</div><div class="line">            if(pending)&#123;</div><div class="line">                pending.push(_callback)</div><div class="line">            &#125;else&#123;</div><div class="line">                _callback();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好，现在我们已经保证不能重复defer.resolve()的问题了，那么我们还希望可以实现通过链式调用来添加回调。可是目前要只能通过defer().then(callback1),defer().then(callback2),defer().then(callback3)这种方式添加回调，这显然不是我们想要的方式。接下来我们将一步一步实现。</p>
<h4 id="三、promise职责分离"><a href="#三、promise职责分离" class="headerlink" title="三、promise职责分离"></a>三、promise职责分离</h4><p>但是在实现链式回调之前，为了后期结构，我们希望对我们的promise进行职责区分，一个注册观察者，一个执行观察者。根据最少授权原则，我们希望如果授权给某人一个promise，这里只允许他增加观察者；如果授权给某人resolver，他应当仅仅能决定什么时候给出解决方案。因为大量实验表明任何任何不可避免的越权行为会导致后续的改动变得很难维护。（其实就是希望把添加回调的then功能移植到promise中，从defer.then转变成defer.promise.then，保证功能的纯粹性）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">let defer = () =&gt; &#123;</div><div class="line">    let pending = [],value;</div><div class="line">    return &#123;</div><div class="line">        resolve(_value)&#123;</div><div class="line">            if(pending)&#123;</div><div class="line">                value = _value</div><div class="line">                for(let i = 0;i &lt; pending.length; i++)&#123;</div><div class="line">                    pending[i](value)</div><div class="line">                &#125;</div><div class="line">                pending = undefined;</div><div class="line">            &#125;else&#123;</div><div class="line">                throw new Error(&quot;A promise can only be resolved once.&quot;)</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        promise: &#123;</div><div class="line">            then (callback) &#123;</div><div class="line">                if (pending) &#123;</div><div class="line">                    pending.push(callback);</div><div class="line">                &#125; else &#123;</div><div class="line">                    callback(value);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当职责分离完之后，我们就可以接下去实现一步关键的改造</p>
<h4 id="四、promise的链式调用"><a href="#四、promise的链式调用" class="headerlink" title="四、promise的链式调用"></a>四、promise的链式调用</h4><p>上文说道要实现链式回调，我们首先要能在下一个回调函数里接受上一个回调的值。依靠上一步的职责分离的基础，我们接下来要跨非常大的一步，就是使用旧的promise去驱动新的promise。我们希望通过promise组合的使用，来实现值的传递。</p>
<p>举个例子，让你写一个相加的函数，接受两个回调函数返回的数字相加。大家可以考虑如何实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var twoOneSecondLater = function (callback) &#123;</div><div class="line">    var a, b;</div><div class="line">    var consider = function () &#123;</div><div class="line">        if (a === undefined || b === undefined)return;</div><div class="line">        callback(a + b);</div><div class="line">    &#125;;</div><div class="line">    oneOneSecondLater(function (_a) &#123;</div><div class="line">        a = _a;</div><div class="line">        consider();</div><div class="line">    &#125;);</div><div class="line">    oneOneSecondLater(function (_b) &#123;</div><div class="line">        b = _b;</div><div class="line">        consider();</div><div class="line">    &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">twoOneSecondLater(function (c) &#123;</div><div class="line">    // c === 2</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>上面这个方法虽然做到了，但是这个方法是脆弱的，因为我们在执行相加函数时，需要额外的代码去判断相加的数字是否有效。</p>
<p>于是我们希望用更少的代码去实现上面的需求，比如就像下面这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//上面的函数如果用更少的步骤来表达就是</div><div class="line">var a = oneOneSecondLater();</div><div class="line">var b = oneOneSecondLater();</div><div class="line">var c = a.then(function (a) &#123;</div><div class="line">    return b.then(function (b) &#123;</div><div class="line">        return a + b;</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>上面这个例子其实想表达的就是实现callback返回值的传递，如callback1的返回值传给callback2，将callback2的返回值传给callback3。<br>为了实现上面例子的这种效果，我们要实现以下几点</p>
<ul>
<li>每个then方法后必须要返回一个promise</li>
<li>每一个promise被resolve后，返回的必然是一个新的promise或者是一个执行过的值</li>
<li>返回的promise最终可以带着回调的值被resolve掉（这句话有点难翻译，感觉就是promise.resolve(_value)）;</li>
</ul>
</blockquote>
<p>我们实现一个函数可以将获得的值传给下一个回调使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let ref = (value) =&gt; &#123;</div><div class="line">    return &#123;</div><div class="line">        then(callback)&#123;</div><div class="line">            callback(value);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不过考虑到有时候返回的值不仅仅是一个值，而且还可能是一个promise函数，所以我们需要加个判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let ref = (value) =&gt; &#123;</div><div class="line">    if(value &amp;&amp; typeof value.then === &quot;function&quot;)&#123;</div><div class="line">        return value;</div><div class="line">    &#125;</div><div class="line">    return &#123;</div><div class="line">        then(callback)&#123;</div><div class="line">            callback(value);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样子我们在使用中就不需要考虑传入的值是一个普通值还是一个promise了。</p>
<p>接下来，为了能使then方法也能返回一个promise，我们来改造下then方法；我们强制将callback的返回值传入下一个promise并立即返回。<br>这个例子存储了回调的值，并在下一个回调中执行了。但是上面第三点没有实现，因为返回值可能是一个promise，那么我们继续改进一下方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let ref = (value) =&gt; &#123;</div><div class="line">    if(value &amp;&amp; typeof value.then === &quot;function&quot;)&#123;</div><div class="line">        return value;</div><div class="line">    &#125;</div><div class="line">    return &#123;</div><div class="line">        then(callback)&#123;</div><div class="line">            return ref(callback(value));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过这一步增强之后，基本上就可以做到获得上一个回调值并不断链式调用下去了。</p>
<p>接下去我们考虑到一种比较复杂的情况，就是defer中存储的回调会在未来某个时间调用。于是我们需要在defer里面将回调进行一次封装，我们将回调中执行完后通过then方法去驱动下一个promise并传递一个返回值。</p>
<p>此外，<strong>resolve</strong>方法应该能处理本身是一个promise的情况，resolve可以将值传递给promise。因为不管是ref还是defer都可以返回一个then方法。如果promise是ref类型的，将会通过then(callback)立即执行回调。如果是promise是defer类型的，callback暂时被存储起来，依靠下一个then(callback)调用才能执行；所以变成了callback可以监听一个新的promise以便能获取完全执行后的value。</p>
<p>根据以上要求，得出了下面最终版的promise<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">let isPromise = (value) =&gt; &#123;</div><div class="line">    return value &amp;&amp; typeof value.then === &quot;function&quot;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let ref = (value) =&gt; &#123;</div><div class="line">    if (value &amp;&amp; typeof value.then === &quot;function&quot;)</div><div class="line">        return value;</div><div class="line">    return &#123;</div><div class="line">        then (callback) &#123;</div><div class="line">            return ref(callback(value));</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let defer = () =&gt; &#123;</div><div class="line">    let pending = [], value;</div><div class="line">    return &#123;</div><div class="line">        resolve: function (_value) &#123;</div><div class="line">            if (pending) &#123;</div><div class="line">                value = ref(_value); // values wrapped in a promise</div><div class="line">                for (let i = 0, ii = pending.length; i &lt; ii; i++) &#123;</div><div class="line">                    let callback = pending[i];</div><div class="line">                    value.then(callback); // then called instead</div><div class="line">                &#125;</div><div class="line">                pending = undefined;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        promise: &#123;</div><div class="line">            then: function (_callback) &#123;</div><div class="line">                let result = defer();</div><div class="line">                // callback is wrapped so that its return</div><div class="line">                // value is captured and used to resolve the promise</div><div class="line">                // that &quot;then&quot; returns</div><div class="line">                let callback = function (value) &#123;</div><div class="line">                    result.resolve(_callback(value));</div><div class="line">                &#125;;</div><div class="line">                if (pending) &#123;</div><div class="line">                    pending.push(callback);</div><div class="line">                &#125; else &#123;</div><div class="line">                    value.then(callback);</div><div class="line">                &#125;</div><div class="line">                return result.promise;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let a = defer();</div><div class="line">a.promise.then(function(value)&#123;console.log(value);return 2&#125;).then(function(value)&#123;console.log(value)&#125;);</div><div class="line">a.resolve(1);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>将defer分为两个部分，一个是promise，一个是resolve</p>
</blockquote>
<p>到了这一步基本上的promise功能已经实现了，可以链式调用，可以在自己控制在未来某个时间resolve。接下去就是功能的增强和补足了。</p>
<p>这一块回调基本上就写完了，看了很久原文的描述，对着代码理解作者想表达的意思。不过英语不太好，写的磕磕绊绊。╮(╯▽╰)╭，感觉还是有些地方写的不对。希望有人能够纠错出来。</p>
<h4 id="五、提供错误的回调"><a href="#五、提供错误的回调" class="headerlink" title="五、提供错误的回调"></a>五、提供错误的回调</h4><p>为了实现错误消息的传递，我们还需要一个错误的回调函数(errback)。就像promise完全执行时调用callback一样，它会告知执行errback以及告诉我们拒绝的原因。</p>
<p>实现一个类似于前面ref的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let reject = (reason) =&gt; &#123;</div><div class="line">    return &#123;</div><div class="line">        then(callback,errback)&#123;</div><div class="line">            return ref(errback(reason);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最简单的实现方法是当监听到返回值时，立即执行代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">reject(&quot;Meh.&quot;).then((value) =&gt; &#123;&#125;,(reason) =&gt; &#123;</div><div class="line">    throw new Error(reason);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么接下来我们改进原来promsie这个API，引入“errback”。</p>
<p>为了将错误回调添加到代码中，defer需要添加一种新的容器来添加成功回调和错误回调。因此之前那个存储在数组(pending)中的只有一种待处理回调函数，我们需要重新设计一个同时包含成功回调和错误回调的数组([callback,errback]),根据then传入的参数决定调用哪个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">var defer = function () &#123;</div><div class="line">    var pending = [], value;</div><div class="line">    return &#123;</div><div class="line">        resolve: function (_value) &#123;</div><div class="line">            if (pending) &#123;</div><div class="line">                value = ref(_value);</div><div class="line">                for (var i = 0, ii = pending.length; i &lt; ii; i++) &#123;</div><div class="line">                    // apply the pending arguments to &quot;then&quot;</div><div class="line">                    value.then.apply(value, pending[i]);</div><div class="line">                &#125;</div><div class="line">                pending = undefined;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        promise: &#123;</div><div class="line">            then: function (_callback, _errback) &#123;</div><div class="line">                var result = defer();</div><div class="line">                var callback = function (value) &#123;</div><div class="line">                    result.resolve(_callback(value));</div><div class="line">                &#125;;</div><div class="line">                var errback = function (reason) &#123;</div><div class="line">                    result.resolve(_errback(reason));</div><div class="line">                &#125;;</div><div class="line">                if (pending) &#123;</div><div class="line">                    pending.push([callback, errback]);</div><div class="line">                &#125; else &#123;</div><div class="line">                    value.then(callback, errback);</div><div class="line">                &#125;</div><div class="line">                return result.promise;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let ref = (value) =&gt; &#123;</div><div class="line">    if (value &amp;&amp; typeof value.then === &quot;function&quot;)</div><div class="line">        return value;</div><div class="line">    return &#123;</div><div class="line">        then: function (callback) &#123;</div><div class="line">            return ref(callback(value));</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let reject = (reason) =&gt; &#123;</div><div class="line">    return &#123;</div><div class="line">        then: function (callback, errback) &#123;</div><div class="line">            return ref(errback(reason));</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>代码写完了，但是仍然还有地方可以改进。</p>
<p>比如作者说到这一步有一个问题，就是如果按照上面这么写，那么所有的then函数就必须提供错误回调函数(_errback)，如果不提供就会出错。所以最简单的解决方法是提供一个默认的回调函数。甚至文中还说，如果仅仅是对错误回调有需要，那么忽略不写成功回调(_callback)也是可以的。所以为了满足需求，我们为_callback和_errback都提供一个默认的回调函数。（好吧，其实我就是觉得这是一个好的库的容错处理）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">var defer = function () &#123;</div><div class="line">    ...</div><div class="line">    return&#123;</div><div class="line">        ...</div><div class="line">        promise : &#123;</div><div class="line">             then: function (_callback, _errback) &#123;</div><div class="line">                var result = defer();</div><div class="line">                // 提供一个默认的成功回调和错误回调</div><div class="line">                _callback = _callback || function (value) &#123;</div><div class="line">                    // 默认执行</div><div class="line">                    return value;</div><div class="line">                &#125;;</div><div class="line">                _errback = _errback || function (reason) &#123;</div><div class="line">                    // 默认拒绝</div><div class="line">                    return reject(reason);</div><div class="line">                &#125;;</div><div class="line">                var callback = function (value) &#123;</div><div class="line">                    result.resolve(_callback(value));</div><div class="line">                &#125;;</div><div class="line">                var errback = function (reason) &#123;</div><div class="line">                    result.resolve(_errback(reason));</div><div class="line">                &#125;;</div><div class="line">                if (pending) &#123;</div><div class="line">                    pending.push([callback, errback]);</div><div class="line">                &#125; else &#123;</div><div class="line">                    value.then(callback, errback);</div><div class="line">                &#125;</div><div class="line">                return result.promise;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好了，现在我们已经实现了接收构造或者隐含的错误回调<a href="https://github.com/kriskowal/q/blob/v1/design/q6.js" target="_blank" rel="external">这一步的完成版</a></p>
<h4 id="六、安全性和稳定性"><a href="#六、安全性和稳定性" class="headerlink" title="六、安全性和稳定性"></a>六、安全性和稳定性</h4><p>我们还有需要需要提高的地方就是要保证callbacks和errbacks在未来他们被调用的时候，应该是和注册时的顺序是保持一致的。这将显著降低异步编程中流程控制出错可能性。文中举了一个有趣的小例子.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var blah = function () &#123;</div><div class="line">    var result = foob().then(function () &#123;</div><div class="line">        return barf();</div><div class="line">    &#125;);</div><div class="line">    var barf = function () &#123;</div><div class="line">        return 10;</div><div class="line">    &#125;;</div><div class="line">    return result;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>上面这个函数在执行后会出现两种情况，一是抛出一个异常，二是顺利执行并返回了值10。而决定是哪个结果的是foob()是否在正确顺序里。因为我们希望哪怕回调在未来被延迟执行了，它能够执行成功。</p>
<p>下面添加了一个enqueue方法，我的理解就是依靠setTimeout的异步将所有回调按照顺序添加到任务队列中，保证按照顺序执行代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">let enqueue = (callback) =&gt; &#123;</div><div class="line">    setTimeout(callback,1)</div><div class="line">&#125;</div><div class="line">let enqueue = (callback) =&gt; &#123;</div><div class="line">    //process.nextTick(callback); // NodeJS</div><div class="line">    setTimeout(callback, 1); // Naïve browser solution</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let defer = function () &#123;</div><div class="line">    let pending = [], value;</div><div class="line">    return &#123;</div><div class="line">        resolve: function (_value) &#123;</div><div class="line">            if (pending) &#123;</div><div class="line">                value = ref(_value);</div><div class="line">                for (let i = 0, ii = pending.length; i &lt; ii; i++) &#123;</div><div class="line">                    enqueue(function () &#123;</div><div class="line">                        value.then.apply(value, pending[i]);</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">                pending = undefined;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        promise: &#123;</div><div class="line">            then: function (_callback, _errback) &#123;</div><div class="line">                let result = defer();</div><div class="line">                _callback = _callback || function (value) &#123;</div><div class="line">                    return value;</div><div class="line">                &#125;;</div><div class="line">                _errback = _errback || function (reason) &#123;</div><div class="line">                    return reject(reason);</div><div class="line">                &#125;;</div><div class="line">                let callback = function (value) &#123;</div><div class="line">                    result.resolve(_callback(value));</div><div class="line">                &#125;;</div><div class="line">                let errback = function (reason) &#123;</div><div class="line">                    result.resolve(_errback(reason));</div><div class="line">                &#125;;</div><div class="line">                if (pending) &#123;</div><div class="line">                    pending.push([callback, errback]);</div><div class="line">                &#125; else &#123;</div><div class="line">                    // XXX</div><div class="line">                    enqueue(function () &#123;</div><div class="line">                        value.then(callback, errback);</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">                return result.promise;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let ref = function (value) &#123;</div><div class="line">    if (value &amp;&amp; value.then)</div><div class="line">        return value;</div><div class="line">    return &#123;</div><div class="line">        then: function (callback) &#123;</div><div class="line">            let result = defer();</div><div class="line">            // XXX</div><div class="line">            enqueue(function () &#123;</div><div class="line">                result.resolve(callback(value));</div><div class="line">            &#125;);</div><div class="line">            return result.promise;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let reject = function (reason) &#123;</div><div class="line">    return &#123;</div><div class="line">        then: function (callback, errback) &#123;</div><div class="line">            var result = defer();</div><div class="line">            // XXX</div><div class="line">            enqueue(function () &#123;</div><div class="line">                result.resolve(errback(reason));</div><div class="line">            &#125;);</div><div class="line">            return result.promise;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>虽然将需要的回调依照次序添加到了队列中</p>
<p>作者有考虑到一些新的问题，比如</p>
<ul>
<li>callback或者errback必须以同样的顺序被调用</li>
<li>callback或者errback可能会被同时调用</li>
<li>callback或者errback可能会被调用多次</li>
</ul>
<p>于是我们需要找个机会then的回调函数，为了保证当回调函数中程序出错时，可以转入到报错函数中。(其实又是一个库的容错处理，保证代码出错时不中断程序的执行)。</p>
<p>用when方法封装下promise以此阻止错误发生，确保不会有哪些突发性的错误，包括哪些非必需的事件流控制，并且也能使callback和errback各自保持独立。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">var when = function (value, _callback, _errback) &#123;</div><div class="line">    var result = defer();</div><div class="line">    var done;</div><div class="line"></div><div class="line">    _callback = _callback || function (value) &#123;</div><div class="line">        return value;</div><div class="line">    &#125;;</div><div class="line">    _errback = _errback || function (reason) &#123;</div><div class="line">        return reject(reason);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    var callback = function (value) &#123;</div><div class="line">        try &#123;</div><div class="line">            return _callback(value);</div><div class="line">        &#125; catch (reason) &#123;</div><div class="line">            return reject(reason);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    var errback = function (reason) &#123;</div><div class="line">        try &#123;</div><div class="line">            return _errback(reason);</div><div class="line">        &#125; catch (reason) &#123;</div><div class="line">            return reject(reason);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    enqueue(function () &#123;</div><div class="line">        ref(value).then(function (value) &#123;</div><div class="line">            if (done)</div><div class="line">                return;</div><div class="line">            done = true;</div><div class="line">            result.resolve(ref(value).then(callback, errback));</div><div class="line">        &#125;, function (reason) &#123;</div><div class="line">            if (done)</div><div class="line">                return;</div><div class="line">            done = true;</div><div class="line">            result.resolve(errback(reason));</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    return result.promise;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/kriskowal/q/blob/v1/design/q7.js" target="_blank" rel="external">这一步的完整版</a></p>
<h4 id="六、消息传递"><a href="#六、消息传递" class="headerlink" title="六、消息传递"></a>六、消息传递</h4><p>现在这一步来看，promise已经成为了一个具有接受消息功能的类了。Deferred promise根据获得的消息来执行对应的回调函数，返回对应的值。当你接收到完全成功执行的值，则在then中执行成功的回调函数返回msg；获得错误的值则在then中执行错误回调函数，返回错误的原因</p>
<p>因此我们基本可以认为promise这个类可以接受任何的值，包括”then/when”这些信息。这对于一些非立即执行函数的监听非常有用。举个例子，当你发了一个网络请求，等待返回值才能执行函数。我们等待这个请求的往返的过程中浪费了许多时间，而promise仿佛在电脑中另外开了一个线程进行监听这些返回值，然后执行对应的回调函数(这个例子是自己理解举的，非原文，如有不对，欢迎改正)。</p>
<blockquote>
<p>翻到这里有点崩溃了，捂下脑子，接下去感觉有点头疼了，以后再补吧,因为基本形态的promise已经出来。接下去是另外一种需求的promise了</p>
</blockquote>
<p>接下来我们要包装一种新型的promise，这套promise基于一些能发送任意消息的方法之上，可以满足 “get”, “put”, “post”能发送相应的消息，并且能根据返回结果中执行相应的promise。</p>
<hr>
<p>第一次尝试翻译，真的是个体力活，花了快2天的时间，整个人都是炸的。不过所幸是比以前明白了一些恭喜。<br>原文大概讲解了基本的promise构成，但是现在还是有许多方法并没有分析，接下去我按照自己的想法去实现以下promise.all方法。如果写的不好，欢迎大家指正，帮我进步一下，谢谢。（手动捂脸）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/14/16.生活中的经济学原理-----站在巨人的肩膀/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="linzx">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/14/16.生活中的经济学原理-----站在巨人的肩膀/" itemprop="url">第十六章-站在巨人的肩膀</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-14T19:47:44+08:00">
                2017-08-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/《解释的工具-生活中的经济学原理》/" itemprop="url" rel="index">
                    <span itemprop="name">《解释的工具-生活中的经济学原理》</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/08/14/16.生活中的经济学原理-----站在巨人的肩膀/" class="leancloud_visitors" data-flag-title="第十六章-站在巨人的肩膀">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  933
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="《解释的工具-生活中的经济学原理》"><a href="#《解释的工具-生活中的经济学原理》" class="headerlink" title="《解释的工具-生活中的经济学原理》"></a>《解释的工具-生活中的经济学原理》</h4><h6 id="—–第十六章-站在巨人的肩膀"><a href="#—–第十六章-站在巨人的肩膀" class="headerlink" title="—–第十六章-站在巨人的肩膀"></a>—–第十六章-站在巨人的肩膀</h6><p>这章也是本书的最后一章了，看到这里，我不禁问自己两个问题，1.站在经济学的角度，你是否有培养出抽象思考的能力，面对社会的各种现象，是否有一套自己的理论而不是依然人云亦云。2.站在了巨人肩膀上，你是否理解了经济学的思维呢。</p>
<p>第一章节对于人性的分析即生活经济学，让我明白了我们生活中很多不知不觉的习惯其实就是经济学思维的影响，理性与自利的人性，懒惰的天性，信任的价值都是生活中的经济哲学。</p>
<p>第二章的社会经济学则解释了许多社会想象的产生，冷漠的围观者，无情的竞争，残忍的管制都可以由经济学的成本分析。幸运的是，我还相信这中国会变得原来越好，而不是我再网上看到各种黑暗的地方。</p>
<p>第三章政治经济学解释了许多国家政策产生的原因以及我们普通人在这些政策之下受到的影响。无奈的是，虽然我明白了这些政策的最终方向，可是却无法改变自己在大潮下的走势。逆水行舟，不进则退啊。</p>
<p>第四章的法律经济学有时候看得我心惊胆战，世界上是否存在真正的公平与正义，你所看到的真的对的，有价值，有意义的吗？面对真正的选择，跳出自己所在的层面，站在更多更高的角度，也许会发现更多之前没有考虑到的，然后做出的取舍，才显得更加的“公平与正义”。</p>
<p>纵览全书，又人及社会及政治及法律，经济学有由小到大，由点及面，细细解析其所影响的各个层面。归纳出最后4点。</p>
<h5 id="1-人是理性的，自私的。"><a href="#1-人是理性的，自私的。" class="headerlink" title="1. 人是理性的，自私的。"></a>1. 人是理性的，自私的。</h5><p>人们是会思索判断的生物，大多数行为总是为了增添自己（或者自己周围人的福祉）。引申出来的许多懒惰的特性也是由此而来。</p>
<h5 id="2-存在不一定合理，但是存在一定是有原因的。"><a href="#2-存在不一定合理，但是存在一定是有原因的。" class="headerlink" title="2. 存在不一定合理，但是存在一定是有原因的。"></a>2. 存在不一定合理，但是存在一定是有原因的。</h5><p>正是因为行为都是基于理性和自私，所以近年来出现许多冷漠的社会现象（冷眼围观，碰瓷，污蔑）。这些社会现象的出现，都有背后条件的支持————存在不一定合理，但是存在一定是有原因的。</p>
<h5 id="3-好的价值要出现，是有条件的"><a href="#3-好的价值要出现，是有条件的" class="headerlink" title="3. 好的价值要出现，是有条件的"></a>3. 好的价值要出现，是有条件的</h5><p>每个人都希望自己有好的环境，事业上有好的发展，可是这必须你做出一些努力，父母朋友间的互动，自身努力获得好的经济等等。个人小的价值尚且需要这些努力，更大的价值当然需要更困难的条件来支持。所以说，好的价值的出现，是有条件的</p>
<h5 id="4-一件事物的意义，是由其他事物衬托出来的。"><a href="#4-一件事物的意义，是由其他事物衬托出来的。" class="headerlink" title="4. 一件事物的意义，是由其他事物衬托出来的。"></a>4. 一件事物的意义，是由其他事物衬托出来的。</h5><p>最后要说的是我们生活中许多隐含经济学的经验和原则，都是你所在相对环境形成的。如果环境发生改变，则你自己原先所认定的原则自然也会随之发生变化（你要学会拥抱变化）。因此事物的意义，是相对于环境里的各种主管条件，是相对的而不是绝对的。</p>
<p>观点在不断的变化，我们不断的在成长。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/13/基于vue-cli的webpack优化之路/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="linzx">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/13/基于vue-cli的webpack优化之路/" itemprop="url">基于vue-cli的webpack优化之路</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-13T23:47:44+08:00">
                2017-08-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/webpack/" itemprop="url" rel="index">
                    <span itemprop="name">webpack</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/08/13/基于vue-cli的webpack优化之路/" class="leancloud_visitors" data-flag-title="基于vue-cli的webpack优化之路">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  1,990
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  8
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>最近的项目度过了开始忙碌的基建期，也慢慢轻松下来，准备记录一下自己最近webpack优化的措施，希望有温故知新的效果。</p>
</blockquote>
<p>项目采用的是vue全家桶，构建配置都是基于vue-cli去改进的。关于原始webpack配置大家可以看下这篇文章<a href="https://github.com/DDFE/DDFE-blog/issues/10" target="_blank" rel="external">vue-cli#2.0 webpack配置分析</a>,文章基本对于文件每行代码都做了详细的解释，有助于更好的理解webpack。<br><a href="https://github.com/linzx1993/APS-ng-vue-/tree/master/mes" target="_blank" rel="external">项目位置链接</a></p>
<p>仔细总结了一下，自己的优化基本还是网上流传的那几点</p>
<ul>
<li>通过 externals 配置来提取常用库，引用cdn</li>
<li>合理配置CommonsChunkPlugin</li>
<li>善用alias</li>
<li>dllplugin启用预编译</li>
<li>happypack多核构建项目</li>
</ul>
<p>不过经过自己的实践最后三点是对自己项目优化最大的。文章也主要对后面几点详细说明一下</p>
<p>对了，我项目引用了vue全家桶一套,jquery以及两个第三方插件，element-ui,echarts，自己项目的组件大概有40个左右</p>
<p>原来打包一个项目所需要的时间基本在35-40秒左右(第二次有缓存会稍微快一点)，但是偶尔来一次大姨妈，时间甚至要到50s左右，我也是醉了。不过大家可以期待一下经过下面这三步优化大概需要多久。</p>
<h4 id="1-使用dllplugin预编译与引用"><a href="#1-使用dllplugin预编译与引用" class="headerlink" title="1.使用dllplugin预编译与引用"></a>1.使用dllplugin预编译与引用</h4><p>首先为什么要引用Dll？在网上浏览了一些文章后，我发现上除了加快构建速度以外，使用webpack的dll还有一个好处。</p>
<p><strong>Dll打包以后是独立存在的，只要其包含的库没有增减、升级，hash也不会变化，因此线上的dll代码不需要随着版本发布频繁更新。</strong> 因为使用Dll打包的基本上都是独立库文件，这类文件有一个特性就是变化不大。当我们正常打包这些库文件到一个app.js里的时候，由于其他业务文件的改变，影响了缓存对构建的优化，导致每次都要重新去npm包里寻找相关文件。而使用了DLL之后，只要包含的库没有升级， 增减，就不需要重新打包。这样也提高了构建速度。</p>
<p>那么如何使用Dll去优化项目呢<br>首先要建立一个dll的配置文件,引入项目所需要的第三方库。这类库的特点是不需要随着版本发布频繁更新，长期稳定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">const webpack = require(&apos;webpack&apos;);</div><div class="line">const path = require(&apos;path&apos;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  entry: &#123;</div><div class="line">    //你需要引入的第三方库文件</div><div class="line">    vendor: [&apos;vue&apos;,&apos;vuex&apos;,&apos;vue-router&apos;,&apos;element-ui&apos;,&apos;axios&apos;,&apos;echarts/lib/echarts&apos;,&apos;echarts/lib/chart/bar&apos;,&apos;echarts/lib/chart/line&apos;,&apos;echarts/lib/chart/pie&apos;,</div><div class="line">      &apos;echarts/lib/component/tooltip&apos;,&apos;echarts/lib/component/title&apos;,&apos;echarts/lib/component/legend&apos;,&apos;echarts/lib/component/dataZoom&apos;,&apos;echarts/lib/component/toolbox&apos;],</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  output: &#123;</div><div class="line">    path: path.join(__dirname, &apos;dist-[hash]&apos;),</div><div class="line">    filename: &apos;[name].js&apos;,</div><div class="line">    library: &apos;[name]&apos;,</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  plugins: [</div><div class="line">    new webpack.DllPlugin(&#123;</div><div class="line">      path: path.join(__dirname, &apos;dll&apos;, &apos;[name]-manifest.json&apos;),</div><div class="line">      filename: &apos;[name].js&apos;,</div><div class="line">      name: &apos;[name]&apos;,</div><div class="line">    &#125;),</div><div class="line">  ]</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>基本配置参数和webpack基本一模一样，相信来看优化的都明白什么意思，我就不解释了。然后执行代码编译文件。<strong>(我的配置文件是放在build里面，下方路径根据项目路径需要变动)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack -p --progress --config build/webpack.dll.config.js</div></pre></td></tr></table></figure></p>
<p>当运行完执行后，会生成两个新文件在目录同级，一个是生成在dist文件夹下的<strong>verdor.js</strong>，里面是刚刚入口依赖被压缩后的代码;一个是dll文件夹下的<strong>verdor-manifest.json</strong>，将每个库进行了编号索引，并且使用的是id而不是name。</p>
<p>接下去你只要去你的webpack配置文件的里的plugin中添加一行代码就ok了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const manifest = require(&apos;./dll/vendor-manifest.json&apos;);</div><div class="line">...</div><div class="line">...,</div><div class="line">plugin:[</div><div class="line">    new webpack.DllReferencePlugin(&#123;</div><div class="line">        context: __dirname,</div><div class="line">        manifest,</div><div class="line">    &#125;),</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>这时候再执行webpack命令，可以发现时间直接从40秒锐减到了18-20s左右，整整快了一倍有木有(不知道是不是因为自己依赖库太多了才这样的，手动捂脸)。</p>
<h4 id="2-happypack多线程编译"><a href="#2-happypack多线程编译" class="headerlink" title="2.happypack多线程编译"></a>2.happypack多线程编译</h4><p>一般node.js是单线程执行编译，而<a href="https://github.com/amireh/happypack" target="_blank" rel="external">happypack</a>则是启动node的多线程进行构建，大大提高了构建速度。使用方法也比较简单。以我项目为例,在插件中new一个新的happypack进程出来，然后再使用使用loader的地方替换成对应的id<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">var HappyPack = require(&apos;happypack&apos;);</div><div class="line">...</div><div class="line">...</div><div class="line">modules:&#123;</div><div class="line">    rules : [</div><div class="line">        ...</div><div class="line">        &#123;</div><div class="line">            test: /\.js$/,</div><div class="line">            loader:[ &apos;happypack/loader?id=happybabel&apos;],</div><div class="line">            include: [resolve(&apos;src&apos;)]</div><div class="line">        &#125;,</div><div class="line">        ...</div><div class="line">    ]</div><div class="line">&#125;,</div><div class="line">...</div><div class="line">...</div><div class="line">plugin:[</div><div class="line">    //happypack对对 url-loader,vue-loader 和 file-loader 支持度有限，会有报错，有坑。。。</div><div class="line">    new HappyPack(&#123;</div><div class="line">          id: &apos;happybabel&apos;,</div><div class="line">          loaders: [&apos;babel-loader&apos;],</div><div class="line">          threads: 4,//HappyPack 使用多少子进程来进行编译</div><div class="line">    &#125;),</div><div class="line">    new HappyPack(&#123;</div><div class="line">          id: &apos;scss&apos;,</div><div class="line">          threads: 4,</div><div class="line">          loaders: [</div><div class="line">                &apos;style-loader&apos;,</div><div class="line">                &apos;css-loader&apos;,</div><div class="line">                &apos;sass-loader&apos;,</div><div class="line">          ],</div><div class="line">    &#125;)</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>这时候再去执行编译webpack的代码，打印出来的console则变成了另外一种提示。而编译时间大概从20s优化到了15s左右(感觉好像没有网上说的那么大，不知道是不是因为本身js比重占据太大的缘故)。</p>
<h4 id="3-配合resolve，善用alias"><a href="#3-配合resolve，善用alias" class="headerlink" title="3.配合resolve，善用alias"></a>3.配合resolve，善用alias</h4><p>本来是没有第三点的，只不过在搜索网上webpack优化相关文章的时候，看到用人提到把引入文件改成库提供的文件(原理我理解其实就是1.先通过resolve指定文件寻找位置，减小搜索范围；2.直接根据alias找到库提供的文件位置)。</p>
<p>vue-cli配置文件中提示也有提到这一点，就是下面这段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">resolve: &#123;</div><div class="line">    //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名</div><div class="line">    extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;],</div><div class="line">    //模块别名定义，方便后续直接引用别名，无须多写长长的地址</div><div class="line">    alias: &#123;</div><div class="line">      &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;,//就是这行代码，提供你直接引用文件</div><div class="line">      &apos;@&apos;: resolve(&apos;src&apos;),</div><div class="line">    &#125;</div><div class="line">  &#125;,</div></pre></td></tr></table></figure></p>
<p>然后我将其他所有地方关于vue的引用都替换成了vue$之后，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// import &apos;vue&apos;;</div><div class="line">import &apos;vue/dist/vue.esm.js&apos;;</div></pre></td></tr></table></figure></p>
<p>时间竟然到了12s，也是把我吓了一跳。。。</p>
<p>然后我就把jquery，axios，vuex等等全部给替换掉了。。。不过变化没有特别大，大概优化到了11s左右，美滋滋，O(∩_∩)O~~。如果有缓存的情况下，基本上大概在9s左右</p>
<h4 id="4-webpack3升级"><a href="#4-webpack3升级" class="headerlink" title="4.webpack3升级"></a>4.webpack3升级</h4><p>本来是没第四点，刚刚看到公众号推出来一篇文章讲到升级到webpack3的一些新优点，比如<strong>Scope Hoisting</strong>(webpack2升级到webpack3基本上没有太大问题)。通过添加一个新的插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//  2017-08-13配合最新升级的webpack3提供的新功能，可以使压缩的代码更小，运行更快</div><div class="line">...</div><div class="line">plugin : [</div><div class="line">    new webpack.optimize.ModuleConcatenationPlugin(),</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>不过在添加这行代码之后，构建时间并没有太大变化。因为它的优点是提供js在浏览器中的运行速度。webpack2会把每个处理后的模块用一个函数包裹起来，导致浏览器中的JS执行效率降低，主要是因为闭包函数降低了JS引擎解析速度。</p>
<blockquote>
<p>不过在浏览器中国的实际效果感觉不出来太大差别</p>
</blockquote>
<p>然后还有一个是webpack3中所有的模块支持用ID进行标记，如果重复引用相同的模块</p>
<h4 id="5-去除不必要的文件"><a href="#5-去除不必要的文件" class="headerlink" title="5.去除不必要的文件"></a>5.去除不必要的文件</h4><p>因为要引入代码高亮的highlight.js插件，webpack会引入里面有各个语言的js文件，但是我们项目只需要js,html,css。搜了一下发现网上已经有类似的解决方法了，ContextReplacementPlugin会根据你写的正则去匹配你需要的文件。</p>
<p>而且自己记得webpack3的升级中有个新特性<code>tree shaking</code>就是可以从文件树中去除不必要的文件。</p>
<p>好了基本上感觉就是以上这些效果对项目的优化最大，虽然没有到网上说的那种只要3~4秒时间那么变态，不过感觉基本9-12秒的时间也可以了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/12/重温vue双向绑定原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="linzx">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/12/重温vue双向绑定原理/" itemprop="url">重温vue双向绑定原理</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-12T23:47:44+08:00">
                2017-08-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vue/" itemprop="url" rel="index">
                    <span itemprop="name">vue</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/08/12/重温vue双向绑定原理/" class="leancloud_visitors" data-flag-title="重温vue双向绑定原理">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  2,224
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  9
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>摘要：因为项目刚开始用的vue框架，所以早期也研究了一下他的代码看过相关文章的解析，说说也能说个七七八八。不过今天再去看以前的demo的时候，发现忽然一知半解了，说明当时可能也没有理解透，所以写篇文章让自己理解的更深一些。</p>
</blockquote>
<p>本篇文章大多数知识点实在学习了这篇<a href="http://www.cnblogs.com/kidney/p/6052935.html?utm_source=gold_browser_extension" target="_blank" rel="external">Vue.js双向绑定的实现原理</a>之后避免遗忘，所以写这个温故知新，加强理解。</p>
<p><a href="https://github.com/linzx1993/APS-ng-vue-/tree/master/mes" target="_blank" rel="external">项目位置链接</a></p>
<hr>
<h4 id="一、访问器属性"><a href="#一、访问器属性" class="headerlink" title="一、访问器属性"></a>一、访问器属性</h4><p>如果稍微看过相关文章的人都知道vue的实现是依靠Object.defineproperty()来实现的。每个对象都有自己内置的set和get方法，当每次使用set时，去改变引用该属性的地方，从而实现数据的双向绑定。简单举例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">const obj = &#123;&#125;;</div><div class="line">Object.defineProperty(obj,&apos;hello&apos;,&#123;</div><div class="line">    get(value)&#123;</div><div class="line">        console.log(&quot;啦啦啦，方法被调用了&quot;);</div><div class="line">    &#125;,</div><div class="line">    set(newVal,oldVal)&#123;</div><div class="line">        console.log(&quot;set方法被调用了，新的值为&quot; + newVal)</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line">obj.hello; //get方法被调用了</div><div class="line">obj.hello = &quot;1234&quot;; //set方法被调用了</div></pre></td></tr></table></figure>
<h4 id="二、极简双向绑定的实现"><a href="#二、极简双向绑定的实现" class="headerlink" title="二、极简双向绑定的实现"></a>二、极简双向绑定的实现</h4><p>基于这个原理，如果想实现显示文字根据输入input变化，实现一个简单版的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;input type=&quot;text&quot; id=&quot;a&quot;/&gt;</div><div class="line">&lt;span id=&quot;b&quot;&gt;&lt;/span&gt;</div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line">    const obj = &#123;&#125;;</div><div class="line">    Object.defineProperty(obj,&apos;hello&apos;,&#123;</div><div class="line">        get()&#123;</div><div class="line">            console.log(&quot;啦啦啦，方法被调用了&quot;);</div><div class="line">        &#125;,</div><div class="line">        set(newVal)&#123;</div><div class="line">            document.getElementById(&apos;a&apos;).value = newVal;</div><div class="line">            document.getElementById(&apos;b&apos;).innerHTML = newVal;</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    document.addEventListener(&apos;keyup&apos;,function(e)&#123;</div><div class="line">        obj.hello = e.target.value;</div><div class="line">    &#125;)</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>上面这个实例实现的效果是：随着文本框输入文字的变化，span会同步显示相同的文字内容。同时在控制台用js改变obj.hello，视图也会更新。这样就实现了view-&gt;model，model-&gt;view的双向绑定。</p>
<h4 id="三、拆解任务，实现vue的双向数据绑定"><a href="#三、拆解任务，实现vue的双向数据绑定" class="headerlink" title="三、拆解任务，实现vue的双向数据绑定"></a>三、拆解任务，实现vue的双向数据绑定</h4><p>我们最终实现下面vue的效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;app&quot;&gt;</div><div class="line">    &lt;input type=&quot;text&quot; v-model=&quot;text&quot;/&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;script&gt;</div><div class="line">const vm = new Vue(&#123;</div><div class="line">    id : &quot;app&quot;,</div><div class="line">    data : &#123;</div><div class="line">        text : &quot;hello world&quot;</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>1.输入框的文本与文本节点的data数据绑定<br>2.输入框的内容发生变化时，data中的数据也发生变化，实现view-&gt;model的变化<br>3.data中的数据发生变化时，文本节点的内容同步发生变化，实现model-&gt;view的变化</p>
<p>要实现1的要求，则又涉及到了dom的编译，其中有一个DocumentFragment的知识点。</p>
<h4 id="四、DocumentFragment"><a href="#四、DocumentFragment" class="headerlink" title="四、DocumentFragment"></a>四、DocumentFragment</h4><p>众所周知，vue吸收了react虚拟DOM的优点，使用DocumentFragment处理节点，其性能和速度远胜于直接操作dom。vue进行编译时，就是将所有挂载在dom上的子节点进行劫持到使用DocumentFragment处理节点，等到所有操作都执行完毕，将DocumentFragment再一模一样返回到挂载的目标上。</p>
<p>先实现一段劫持函数，将要操作的dom全部劫持到DocumentFragment中，然后再append会原位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;app&quot;&gt;</div><div class="line">    &lt;input type=&quot;text&quot; v-model=&quot;text&quot;/&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;script&gt;</div><div class="line">const app = document.getElementById(&quot;app&quot;);</div><div class="line">const nodetoFragment = (node) =&gt; &#123;</div><div class="line">    const flag = document.createDocumentFragment();</div><div class="line">    let child;</div><div class="line">    whild(child = node.firstChild)&#123;</div><div class="line">        flag.appendChild(child);//不断劫持挂载元素下的所有dom节点到创建的DocumentFragment</div><div class="line">    &#125;</div><div class="line">    return flag</div><div class="line">&#125;</div><div class="line">const dom = nodetoFragment(app);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<h4 id="五、数据初始化绑定"><a href="#五、数据初始化绑定" class="headerlink" title="五、数据初始化绑定"></a>五、数据初始化绑定</h4><p>当已经获取到所有的dom元素之后，则需要对数据进行初始化绑定，这里简单涉及到了模板的编译。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">//  编译HTML模板</div><div class="line">	const compile = (node,vm) =&gt; &#123;</div><div class="line">		const regex = /\&#123;\&#123;(.*)\&#125;\&#125;/;//为临时正则表达式，为demo而生</div><div class="line">		//如果节点类型为元素的话</div><div class="line">		if(node.nodeType === 1)&#123;</div><div class="line">			const attrs = node.attributes;//学到一个新属性。。。</div><div class="line">			for(let i = 0;i &lt; attrs.length; i++)&#123;</div><div class="line">				let attr = attrs[i];</div><div class="line">				if(attr.nodeName === &quot;v-model&quot;)&#123;</div><div class="line">					let name = attr.nodeValue;</div><div class="line">					node.addEventListener(&quot;input&quot;,function (e) &#123;</div><div class="line">					    vm.data[name] = e.target.value;</div><div class="line">					&#125;)</div><div class="line">					node.value = vm.data[name];</div><div class="line">					node.removeAttribute(&quot;v-model&quot;);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		//如果节点类型为文本的话</div><div class="line">		if(node.nodeType === 3)&#123;</div><div class="line">			if(regex.test(node.nodeValue))&#123;</div><div class="line">				let name = RegExp.$1;//获取搭配匹配的字符串，又学到了。。。</div><div class="line">				name = name.trim();</div><div class="line">				node.nodeValue = vm.data[name];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	//劫持挂载元素到虚拟dom</div><div class="line">	let nodeToFragment = (node,vm) =&gt; &#123;</div><div class="line">		const flag = document.createDocumentFragment();</div><div class="line">		let child;</div><div class="line">		while(child = node.firstChild)&#123;</div><div class="line">			compile(child,vm);//绑定数据，插入到虚拟DOM中</div><div class="line">			flag.appendChild(child);</div><div class="line">		&#125;</div><div class="line">		return flag;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	//初始化</div><div class="line">	class Vue &#123;</div><div class="line">		constructor(option)&#123;</div><div class="line">			this.data = option.data;</div><div class="line">			let id = option.el;</div><div class="line">			let dom = nodeToFragment(document.getElementById(id),this);</div><div class="line">			document.getElementById(id).appendChild(dom);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	const vm = new Vue(&#123;</div><div class="line">		el : &quot;app&quot;,</div><div class="line">		data : &#123;</div><div class="line">			text : &quot;hello world&quot;</div><div class="line">		&#125;</div><div class="line">	&#125;)</div></pre></td></tr></table></figure>
<p>通过以上代码先实现了第一个要求，文本框和文本节点已经出现了hello woeld了</p>
<h4 id="六、响应式的数据绑定"><a href="#六、响应式的数据绑定" class="headerlink" title="六、响应式的数据绑定"></a>六、响应式的数据绑定</h4><p>接下来我们要实现数据双向绑定的第一步，即view-&gt;model的绑定。根据之前那个简单的例子看到，我们实时获取input中的值，通过Object.defineProperty将data中的text设置为vm的访问器属性，通过set方法，当我们在设置vm.data的值时，实现数据层的绑定。在这一步，set中要做的操作是更新属性的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">let defineReactive = (obj,key,val) =&gt; &#123;</div><div class="line">    Object.defineProperty(obj,key,&#123;</div><div class="line">        get(val)&#123;</div><div class="line">            return val;</div><div class="line">        &#125;</div><div class="line">    	set(newVal,oldVal)&#123;</div><div class="line">    	    if(newVal === oldVal) return;</div><div class="line">    	    val = newVal;</div><div class="line">    	    console.log(val);</div><div class="line">    	&#125;</div><div class="line">    &#125;)</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//监听数据</div><div class="line">let observe = (obj,vm) =&gt; &#123;</div><div class="line">	Object.keys(obj).forEach((key)=&gt;&#123;</div><div class="line">		defineReactive(vm.data,key,obj[key]);</div><div class="line">	&#125;)</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="七、订阅-发布模式（subscribe-amp-publish）"><a href="#七、订阅-发布模式（subscribe-amp-publish）" class="headerlink" title="七、订阅/发布模式（subscribe&amp;publish）"></a>七、订阅/发布模式（subscribe&amp;publish）</h4><p> text 属性变化了，set方法触发了，可以通过view层的改变实时改变数据，可是并没有改变文本节点的数据。一个新的知识点：订阅发布模式。</p>
<p> 订阅发布模式（又称为观察者模式）定义了一种一对多的关系，让多个观察者同时监听一个主题对象，这个主体对象的改变会通知所有观察者对象。</p>
<p> 发布者发出通知=&gt;主题对象收到通知并推送给订阅者=&gt;订阅者执行操作<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"> //	三个订阅者</div><div class="line">	let sub1 = &#123;updata()&#123;console.log(1);&#125;&#125;;</div><div class="line">	let sub2 = &#123;updata()&#123;console.log(2);&#125;&#125;;</div><div class="line">	let sub3 = &#123;updata()&#123;console.log(3);&#125;&#125;;</div><div class="line"></div><div class="line">	//  一个主题发布器</div><div class="line">	class Dep&#123;</div><div class="line">		constructor()&#123;</div><div class="line">			this.subs = [sub1,sub2,sub3];</div><div class="line">		&#125;</div><div class="line">		notify()&#123;</div><div class="line">			subs.forEach((sub) =&gt; &#123;</div><div class="line">				sub.updata();</div><div class="line">			&#125;)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	const dep = new Dep();</div><div class="line">//	一个发布者</div><div class="line">	const pub = &#123;</div><div class="line">		publish()&#123;</div><div class="line">		    dep.notipy();</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	pub.publish();</div></pre></td></tr></table></figure></p>
<p>上图为一个简单实例，发布者执行发布命令，所有这个主题的订阅者执行更新操作。接下去我们要做的就是，当set方法触发后，input作为发布者，改变了text属性；而文本节点作为订阅者，在收到消息后执行更新操作。</p>
<h4 id="八、双向绑定的实现"><a href="#八、双向绑定的实现" class="headerlink" title="八、双向绑定的实现"></a>八、双向绑定的实现</h4><p>每次new一个新的vue对象时，主要是做了两件事，一件是监听数据：observer(监听数据)，第二个是编译HTML，nodeToFragement(id)。</p>
<p>在监听数据的过程中，会为data中的每一个属性生成一个主题对象。</p>
<p>而在编译HTML的过程中，会为每个与数据绑定的相关节点生成一个订阅者watcher，订阅者watcher会将自己订阅到相应属性的dep中。</p>
<p>在前面的方法中已经实现了：修改输入框内容=&gt;再时间回调中修改属性值=&gt;触发属性的set方法。</p>
<p>接下来要做的是发出通知dep.notify=&gt;发出订阅者的uodate方法=&gt;更新视图。</p>
<p>那么如何将watcher添加到关联属性的dep中呢。</p>
<p>编译HTML过程中，为每一个与data关联的节点生成一个watcher，那么watcher中又发生了什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//  每一个属性节点的watcher</div><div class="line">class Watcher&#123;</div><div class="line">	constructor(vm,node,name)&#123;</div><div class="line">		Dep.target = this;</div><div class="line">		this.name = name;</div><div class="line">		this.node = node;</div><div class="line">		this.vm = vm;</div><div class="line">		this.update();</div><div class="line">		Dep.target = null;</div><div class="line">	&#125;</div><div class="line">	update()&#123;</div><div class="line">		//获得最新值，然后更新视图</div><div class="line">		this.get();</div><div class="line">		this.node.nodeValue = this.value;</div><div class="line">	&#125;</div><div class="line">	get()&#123;</div><div class="line">		this.value = this.vm.data[this.name];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在编译HTML的过程中，生成watcher<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">let complie = (node,vm)&#123;</div><div class="line">    ......</div><div class="line">    //如果节点类型为文本的话</div><div class="line">    if(node.nodeType === 3)&#123;</div><div class="line">	    if(regex.test(node.nodeValue))&#123;</div><div class="line">	        let name = RegExp.$1;</div><div class="line">	        name = name.trim();</div><div class="line">            node.nodeValue = vm.data[name];</div><div class="line">            </div><div class="line">            new Watcher(vm,node,name);//在此处添加订阅者</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先将自己赋给了一个全局变量Dep.target;然后执行了uodate方法，进而执行了get方法，读取了vm的访问器属性，从而触发了访问器属性的get方法，get方法将相应的watcher添加到对应访问器属性的dep中。再次，获取属性的值，然后更新视图。最后将dep.target设置为空，是因为这是个全局变量也是watcher与dep之间唯一的桥梁，任何时间都只能保证只有一个值。（其实就是说全局一个主题，每个订阅者和发布者都是通过这个主题进行沟通。当执行代码时，这个主题接受到一个发布通知，通知完所有订阅者，然后注销掉，用于下一个通知发布。啰嗦了一段就是想讲为什么要设置Dep.target = null）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//  一个主题发布器</div><div class="line">class Dep()&#123;</div><div class="line">    constructor()&#123;</div><div class="line">        this.subs = [];</div><div class="line">    &#125;</div><div class="line">    notify()&#123;</div><div class="line">        this.subs.forEach((sub) =&gt; &#123;</div><div class="line">            sub.update();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    addSub(sub)&#123;</div><div class="line">        this.subs.push(sub);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let defineReactive = (obj,key,val) =&gt; &#123;</div><div class="line">    let dep = new Dep();</div><div class="line">    Object.defineProperty(obk,key,&#123;</div><div class="line">        get()&#123;</div><div class="line">            if(dep.target) dep.addSub(dep.target);</div><div class="line">        &#125;        </div><div class="line">        set(newVal,oldVal)&#123;</div><div class="line">            if(newVal === oldVal) return;</div><div class="line">            val = newVal;</div><div class="line">            dep.notify();</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，hello world 双向绑定就基本实现了。文本内容会随输入框内容同步变化，在控制器中修改 vm.text 的值，会同步反映到文本内容中。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/07/15.生活中的经济学原理-----以管窥天？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="linzx">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/07/15.生活中的经济学原理-----以管窥天？/" itemprop="url">第十五章-以管窥天</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-07T13:47:44+08:00">
                2017-08-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/《解释的工具-生活中的经济学原理》/" itemprop="url" rel="index">
                    <span itemprop="name">《解释的工具-生活中的经济学原理》</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/08/07/15.生活中的经济学原理-----以管窥天？/" class="leancloud_visitors" data-flag-title="第十五章-以管窥天">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  582
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="《解释的工具-生活中的经济学原理》"><a href="#《解释的工具-生活中的经济学原理》" class="headerlink" title="《解释的工具-生活中的经济学原理》"></a>《解释的工具-生活中的经济学原理》</h4><h6 id="—–第十五章-以管窥天？"><a href="#—–第十五章-以管窥天？" class="headerlink" title="—–第十五章-以管窥天？"></a>—–第十五章-以管窥天？</h6><p>工作也慢慢不忙了，生活也慢慢恢复原样了，回到了原来的轨道上面去了。人们的在思考与做每一个决定都是有他的利弊，当下做出的选择。比起做决定，更大的收货是你在做决定时的思维模式。不管你最后的结果怎么样，当你在面对各种现象和问题时，有自己的认知和思索方式，便是你独有的财富。</p>
<p>本章主要想讲述的其实也是这种思维模式的重要性。我们一生中会做出很多选择，你自己有时候也不知道自己做的选择是否正确，就像自己最近感情上做出的选择，你放弃了很多的同时，也会有相应许多的得到的，也许再过了一段时间之后，你会后悔或者遗憾当时你做的选择，但是这就是你在当时情境下自己做的最好的决定。<strong>很多事情有两个选项给你选已经是很幸福的事情了。</strong></p>
<p>经济学在生活中的很多表现其实也就是帮我们做出取舍。看电影，吃饭，睡觉等许多事情不仅仅是由事情本身所决定的，更多会受到周围工作，场景，同事等因素影响。经济学擅长将各个因素抽象化，图表化在心中列出来。自己在思考问题时，可以明确，精致，有效的掌握每一个环节，从而归纳出有意义的结果。也许也会在思考对比的过程中，想出更好的替代方案。</p>
<p>这篇看完后其实没有太多可以分析，但是细细思考，最重要的早已在生活中潜移默化的影响了我们。以后在做每个决定时，独立全面的思考决定所带来的利弊，也许几年后在后悔自己sb的举动，但是至少你曾经细致的去想过每个选项，在你当时的情境下做出最好的选择。并且如果你真的当你思考全面当作出后，也不要再纠结了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/27/14.生活中的经济学原理-----司法女神的举止/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="linzx">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/27/14.生活中的经济学原理-----司法女神的举止/" itemprop="url">第十四章-司法女神的举止</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-27T13:47:44+08:00">
                2017-07-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/《解释的工具-生活中的经济学原理》/" itemprop="url" rel="index">
                    <span itemprop="name">《解释的工具-生活中的经济学原理》</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/07/27/14.生活中的经济学原理-----司法女神的举止/" class="leancloud_visitors" data-flag-title="第十四章-司法女神的举止">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  879
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="《解释的工具-生活中的经济学原理》"><a href="#《解释的工具-生活中的经济学原理》" class="headerlink" title="《解释的工具-生活中的经济学原理》"></a>《解释的工具-生活中的经济学原理》</h4><h6 id="—–第十四章-司法女神的举止"><a href="#—–第十四章-司法女神的举止" class="headerlink" title="—–第十四章-司法女神的举止"></a>—–第十四章-司法女神的举止</h6><p>好久好久没有看书了，一是因为最近的项目是在是太紧张了，要赶在deadline前完成，同时手贱半个月前空的时候接了个私活，更加忙的不可开交。好不容易等忙完了，好了，吃了个特辣的香锅整个人身体垮了。也算明白了一个道理，欠的账总是要还的。你加班忙碌期的疲惫会在你松懈下的那一刻爆发不来的。</p>
<h5 id="好了，回到正题"><a href="#好了，回到正题" class="headerlink" title="好了，回到正题"></a>好了，回到正题</h5><hr>
<p>这是法律经济学的最后一篇。之前的对此有的印象似乎已经有点模糊了。只记得法律经济学告诉我们许多法律上的制定可以由经济效益为出发点进行考虑，会发现许多案例有不一样的发现。</p>
<p>本章最明显的一个例子是火车撞小孩的故事，一个小孩在看清楚了告示之后在不会有火车经过的铁轨上玩耍，而另外5个小孩却仍然在火车要通过的铁道上玩耍。没过多久，火车匆匆而至，身为扳道工的你是否会让火车转入另一条，去撞那位对的小孩呢??</p>
<p>这个故事很久之前就看到过，我心目里的答案一直不该，因为一个人做错事就应该受到惩罚，凭什么让对的人替错的人去牺牲生命。法律上对就是对，错就是错，如果法律不支持对的事情，那么法律的尊严将消失的无影无踪。在文中则给出了另外几种思路，比如从小孩成长后的价值，5个富孩子家庭背景去弥补穷孩子的损失。这几种说法虽然角度独特，却也没有给予我震动感。不过当文中说道<strong>如果是100个孩子呢，1000个孩子呢，那么你是否还会去撞吗？</strong> 我感觉我的想法已经改变了，我也许会去牺牲那个人吧。法律固然是公平与正义的，可是在规则与例外之间的取舍，却显得更加慎重与微妙。（好吧，人们总能自圆其说，找到理由来暗示自己）</p>
<p>法律中一些规则的制定是否需要考虑情理之外的的东西。以火车撞小孩子为例，当你动摇了内心不扳轨道的决定，就说明你已经考虑了情理之外的东西，而不止是法律的公平正义了。现实中其实的确是有许多规则属于这种。对于“恋童癖”判处重刑甚至死刑就属于这个，需要加重惩罚来进行宣示警醒的作用，防患于未然，才能更好的保护孩子。而对未成年人减轻惩罚，对犯人减刑，则是因为他们未来可能会有更大更好的价值。不同的表现都是具有不同的价值的，惩罚是善后的补救措施，遏阻则是着眼于未来长远利益的展望。</p>
<p>哎，真的是感觉从法律经济学的角度去考虑，很多事情则都没有了法律的公平正义可言了。司法女神的尊严真的因为各种各样的情理，价值受到了极大的挑战啊。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/06/13.生活中的经济学原理-----司法有价吗？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="linzx">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/06/13.生活中的经济学原理-----司法有价吗？/" itemprop="url">第十三章-司法有价吗？</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-06T13:47:44+08:00">
                2017-07-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/《解释的工具-生活中的经济学原理》/" itemprop="url" rel="index">
                    <span itemprop="name">《解释的工具-生活中的经济学原理》</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/07/06/13.生活中的经济学原理-----司法有价吗？/" class="leancloud_visitors" data-flag-title="第十三章-司法有价吗？">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  805
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="《解释的工具-生活中的经济学原理》"><a href="#《解释的工具-生活中的经济学原理》" class="headerlink" title="《解释的工具-生活中的经济学原理》"></a>《解释的工具-生活中的经济学原理》</h4><h6 id="—–第十三章-司法有价吗？"><a href="#—–第十三章-司法有价吗？" class="headerlink" title="—–第十三章-司法有价吗？"></a>—–第十三章-司法有价吗？</h6><p>万万没有想到距离上一篇写的文章已经过去了一个月了，看样子最近这个月的工作任务真是太大了。如果用经济学的角度去解析，之所以这么久不工作，只因为我写文章带来的收益没有我最近做项目带来的收益大。我看书加写文章所付出虽然看上去只有一小时的成本，可是这一小时从当下来看，没有为我带来任何收益，我自然会将事情的顺序排在后面。</p>
<hr>
<p>好了，回到正题，本篇讲的是法律经济学。其实在看书的途中，我也越来越感受到文章想表达的东西，在我理解来看，其实就是成本和收益的问题。付出多少成本，拿到多少收益，怎么样实现最大成本收益比，其实就是以经济学的角度去考虑问题。文中提出来的几个事例，如违章过马路收取过路费，有些人愿意缴费用来赶时间，有人愿意0成本过马路，其实都是各自对自己时间效益的评估。政府采用收费来限制行人，而不是竖警示牌，宣传教育，也是因为觉得这样子的收益比是最高的<strong>。所以司法有价吗？缴费违章过马路对吗？过马路这件事当然不对，违法；但是我缴费也是合法维护了规则秩序，所以最终这件事只不过合乎法，违于礼而已。</strong></p>
<p>文中还有一个教育部长的例子也更加证明了经济学在政府中政策的影响。教育部长站在教育领域，希望政府支持更多的精力花在特殊儿童的教育上，他拿出美国一位残疾儿童在三位医护人员的帮助下获取文学奖的例子为佐证，希望发掘更多特殊人才的潜力。可是在商言商，特殊教育固然重要，可是教育领域中的童年教育，初中教育也很重要，如果把资源集中在这一块，是不是也能发挥更多的用处呢。如果在提高一层，站在国家角度，你‘教育‘重要，那么‘环保’重要吗？‘安防’重要吗？等等重要吗？这么一对比，花在特殊教育上的资源还值得吗？教育部长的话站在自身的角度当然也没有错，合乎情理，只不过一旦吧层次提高站在更高的决策位角度，许多问题就从绝对性变为了相对性。<strong>所以教育和面包谁更重要呢？</strong></p>
<p>随着这本书越读越多，其实你也能明白，真正的公平正义是没有的，对公平正义的追求，是建立在一个稳定，成熟的社会，和其背后所愿意付出的资源。<strong>司法女神希望世界充满公平，可是她也只能环抱胸前有限的空间。</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/08/12.生活中的经济学原理-----公平正义的真正意义/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="linzx">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/08/12.生活中的经济学原理-----公平正义的真正意义/" itemprop="url">第十二章-公平正义的真正意义</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-08T13:47:44+08:00">
                2017-06-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/《解释的工具-生活中的经济学原理》/" itemprop="url" rel="index">
                    <span itemprop="name">《解释的工具-生活中的经济学原理》</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/06/08/12.生活中的经济学原理-----公平正义的真正意义/" class="leancloud_visitors" data-flag-title="第十二章-公平正义的真正意义">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  996
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="《解释的工具-生活中的经济学原理》"><a href="#《解释的工具-生活中的经济学原理》" class="headerlink" title="《解释的工具-生活中的经济学原理》"></a>《解释的工具-生活中的经济学原理》</h4><h6 id="—–第十二章-公平正义的真正意义"><a href="#—–第十二章-公平正义的真正意义" class="headerlink" title="—–第十二章-公平正义的真正意义"></a>—–第十二章-公平正义的真正意义</h6><p>第十二章实在是自己政治理解能力不够，看完都还是有点懵懂的，决定还是跨过去了。过两天抽个时间再看一遍，看看温故能不能知新。</p>
<p>接下去几章是法律经济学，其实还是和我们周围的生活有一些息息相关的。看完之后，仔细琢磨了生活中一些规章制度，的确隐含着很多法律经济学的影子。</p>
<p>就我理解来说,法律经济学的观点是衡量一件法律案件是否有理，不应该从绝对的公平正义角度着眼，而值得从经济效益的角度进行评估。</p>
<p>我仔细想想我们公司有些制度也有异曲同工之妙。以孕妇请假为例，假如刚开始的时候公司没有任何相关规定，那么第一位孕妇在刚开始怀孕的时候，可以带薪请假并且同时无条件享受公司各种各样的福利，那么她这种行为会不会对其他人造成心理上的伤害；她同时也在透支的后面孕妇的福利，因为如果她做的这么过分，意味着后面怀孕的人将再也无法享受到类似的福利，因为公司会从成本角度去衡量。也许让一位孕妇员工享受所有的福利应该是正义的，当时它产生的负面影响将会远远大于对公司正面的生产价值。</p>
<p>再以生活中一个很常见的例子进行举例。一个爱妈妈的广告也许在许多人的眼中感到的是温馨，但是一些从小没有母爱的孤儿长大之后看到这个广告，却引起了一丝被刺伤的愤怒。那么当这些人告广告商的时候，难道因为对一部分人造成了伤害，就禁止播放吗？</p>
<p>我相信另一部分人肯定会嗤之以鼻，心里默默念一句凭什么，我就觉得广告拍的很好。当然这只是嘴上的吐槽，我们可以更深入到第二层角度去分析。这支广告固然让一部分人愤怒，可是它同时却让更多的人知道抚慰母亲辛劳，提醒子女孺慕，甚至可能会挽回一些破碎的家庭。它产生的社会价值岂不是更大，如果你不喜欢，你可以拒绝购买广告产品，或者促使周围人一起抵制，但是不应该通过法律来限制。<strong>因为一旦以法律制度来限定，分寸的掌握就变得很微妙了。。更深程度上去看，如果一个人的喜好可以通过法律强加到另外一个人身上，将心比心，你愿意别人用同样的法律来限制你的信仰和喜好吗？你愿意让制度法律的人又那么大权力吗？</strong></p>
<p>文末抛出了一个问题？既然播放伤心的广告可以，那么为什么抽烟不行呢？我的理解来看，因为抽烟对于社会生产成本产生危害将远大于其生产价值吧。我想说，如果抽烟有助于环境健康，身体长寿，同时还能帮助人们，促进社会产值。恐怕结果就完全相反了。</p>
<p>本章真的很有意思，文中提出了许多观点在日常生活中都显得那么无话可说。绝对的公平正义如果会将人类带向灭亡，那么他还有意义吗<strong>我们应该明白公平正义本身并不是目的，只是手段。既然是手段，也就是工具，我们当然应该选择好的工具。</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/06/2.生活中的经济学原理-----稻草人的由来/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="linzx">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/06/2.生活中的经济学原理-----稻草人的由来/" itemprop="url">第二章-稻草人的由来</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-06T13:47:44+08:00">
                2017-06-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/《解释的工具-生活中的经济学原理》/" itemprop="url" rel="index">
                    <span itemprop="name">《解释的工具-生活中的经济学原理》</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/06/06/2.生活中的经济学原理-----稻草人的由来/" class="leancloud_visitors" data-flag-title="第二章-稻草人的由来">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  1,305
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="《解释的工具-生活中的经济学原理》"><a href="#《解释的工具-生活中的经济学原理》" class="headerlink" title="《解释的工具-生活中的经济学原理》"></a>《解释的工具-生活中的经济学原理》</h4><h6 id="—–第二章-稻草人的由来"><a href="#—–第二章-稻草人的由来" class="headerlink" title="—–第二章-稻草人的由来"></a>—–第二章-稻草人的由来</h6><p>本章其实真的很符合我们生活中的经济学原理。开始书中讲到人们一个“贴标签”的行为。人们会不知不觉的给一个人贴上标贴，比如不认识的工作人员，身边的同事和朋友。<strong>我们为什么会喜欢上贴标签？</strong></p>
<p>我经常和周围朋友开玩笑说，懒是推动我们今天便利生活的源泉。而“贴标签”其实也是一个人们一个偷懒的行为。胖的人心胸狭窄，瘦的人工余心计，上海人华而不实，北京人趾高气扬（网上地域黑中常见的言论，这不是标签，更多是恶意的栽赃）。当我们给一个个接触的人打上一个标记之后，将事情简单化，然后根据自己的假设。我们可以很快从以往的经验中取舍自己的行为，然后根据“标签”自身发生的微妙变化，加减一些新的属性，根据这些属性继续调整自己，于是我们终于可以简单的进行交往行事了。所以，<strong>贴标签其实是有功用的，可以降低我们行为的成本</strong>。</p>
<p>但是，贴标签也有他不好的一面。前段时间我的一个好朋友经历了一些事情，一个交往多年的朋友做了一件让她感到意外，并且伤害到她的事情。我在和她不断的交流中，也得出了一些的感悟。我们在和朋友的交往中，如果一个标签贴的成功，并且始终没有改变，它会不断的加深我们的印象。随着时间的流逝，这个人的标签会在我们心中越来越深，如果这时候他做了一件完全不符合你这个“标签”的事情，从而彻底打破自己以往的印象，对于一些感性的人来说，真是一件崩溃的事情。<strong>因为它完全打破了你以往认知人的准则</strong>。最后你将撕下自己多年认知的标签，而打上另一个完全相反的标签，对于心理上的打击，不是亲身经历是感受不到的。这种感觉，更像是 “<strong>背叛</strong>“。</p>
<p>另外一个典型就是由于摘标签过于麻烦，所以人们不会轻易改变对一个人的印象。比如当我初次在交往中因为一件小事给人打上“爱占便宜”的标签，我与他之后的交往都会有这方面的考虑。虽然事实上他并不是这样的人，但是又如何呢，我并没有因为这个标签吃亏呀，我为什么要改变呢。<strong>人们总会成长与改变，切勿因为一次事件而固执自己的观点。作为一个互联网人，你须记住，唯一不变的是变化。</strong></p>
<p>降低成本，真的是人们许多行为背后最主要的推动力之一啊。</p>
<p>由点及面，由人到社会。贴标签是降低个人成本的行为，那么制度则更像是降低人们在社会生活成本的代表。制度可能是一种局限行为的束缚，但是也是人们利用的一种资产。</p>
<p>在一些带部队的纪录片中，更讲究强调“带兵带心”，而不是“带兵带行”。源于人们只有从心底里认可一样东西之后，才会不自觉的去遵守它。许多规章制度也是一样的道理，如果每个人都可以遵守一项制度成本，那么人们在社会中生活的成本也会降低很多。</p>
<p>如果在道路上只有一个人，那么我们想怎么走就怎么走，但是当有各种不同性格，年龄，性别的人处在同一环境的时候，我们会不自觉的做出一些公共的行为，时日一久，大家基本遵守这种行为时，一个为众人支持和运用的小制度就诞生了。当团队里面的人越来越多，接触越来越频繁，交往越来越复杂的时候，自然而然的需要更多的规章制度。不过制度的关键还是依赖于人，人们首先要相信这个制度，才能遵守和执行。书中有一个故事很典型，美国加州一个市政府将土地低价卖给了一个财团，用于创造就业机会和拉升当地消费行为，获得更多的营业税和财收税。但是如果这个新闻出现在中国，经过新闻媒体的报道，人们首先想到的就是政府与财团的狼狈为奸，而不是由此带来的经济效益。这其中的关键点就是信任的问题，也是后面几篇文章中阐述的“社会成本“。社会成本高带来的良性经济循环将会远远甩开反向的恶性循环。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/header.jpg"
               alt="linzx" />
          <p class="site-author-name" itemprop="name">linzx</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">29</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
    <div id="music163player">
        <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=406238&auto=0&height=66"></iframe>
        </iframe>
    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">linzx</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (search_path.endsWith("json")) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("l3F7nF9MmsyTnvM5rI1g7V9s-gzGzoHsz", "TyY2L80HJkN4VjXnTqdDxuWw");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  <div class="bg_content">
      <canvas id="canvas"></canvas>
  </div>
  <script>
  'use strict';

      var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

      function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

      function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

      function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

      var Circle = function () {
         function Circle(x, y) {
              _classCallCheck(this, Circle);

              this.x = x;
              this.y = y;
              this.r = Math.random() * 10;
              this._mx = Math.random();
              this._my = Math.random();
          }

         _createClass(Circle, [{
              key: 'drawCircle',
              value: function drawCircle(ctx) {
                  ctx.beginPath();
                  //arc() 方法使用一个中心点和半径，为一个画布的当前子路径添加一条弧。
                  ctx.arc(this.x, this.y, this.r, 0, 360);
                  ctx.closePath();
                  ctx.fillStyle = 'rgba(204, 204, 204, 0.3)';
                  ctx.fill();
              }
          }, {
              key: 'drawLine',
              value: function drawLine(ctx, _circle) {
                  var dx = this.x - _circle.x;
                  var dy = this.y - _circle.y;
                  var d = Math.sqrt(dx * dx + dy * dy);
                  if (d < 150) {
                      ctx.beginPath();

                      ctx.moveTo(this.x, this.y); //起始点
                      ctx.lineTo(_circle.x, _circle.y); //终点
                      ctx.closePath();
                      ctx.strokeStyle = 'rgba(204, 204, 204, 0.3)';
                      ctx.stroke();
                  }
              }


          }, {
              key: 'move',
              value: function move(w, h) {
                  this._mx = this.x < w && this.x > 0 ? this._mx : -this._mx;
                  this._my = this.y < h && this.y > 0 ? this._my : -this._my;
                  this.x += this._mx / 2;
                  this.y += this._my / 2;
              }
          }]);

          return Circle;
      }();



      var currentCirle = function (_Circle) {
          _inherits(currentCirle, _Circle);

          function currentCirle(x, y) {
              _classCallCheck(this, currentCirle);

              return _possibleConstructorReturn(this, (currentCirle.__proto__ || Object.getPrototypeOf(currentCirle)).call(this, x, y));
          }

          _createClass(currentCirle, [{
              key: 'drawCircle',
              value: function drawCircle(ctx) {
                  ctx.beginPath();

                  //this.r = (this.r < 14 && this.r > 1) ? this.r + (Math.random() * 2 - 1) : 2;
                  this.r = 8;
                  ctx.arc(this.x, this.y, this.r, 0, 360);
                  ctx.closePath();
                  //ctx.fillStyle = 'rgba(0,0,0,' + (parseInt(Math.random() * 100) / 100) + ')'
                  ctx.fillStyle = 'rgba(255, 77, 54, 0.6)';
                  ctx.fill();
              }
          }]);

          return currentCirle;
      }(Circle);


      window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;

      var canvas = document.getElementById('canvas');
      var ctx = canvas.getContext('2d');
      var w = canvas.width = canvas.offsetWidth;
      var h = canvas.height = canvas.offsetHeight;
      var circles = [];
      var current_circle = new currentCirle(0, 0);

      var draw = function draw() {
          ctx.clearRect(0, 0, w, h);
          for (var i = 0; i < circles.length; i++) {
              circles[i].move(w, h);
              circles[i].drawCircle(ctx);
              for (var j = i + 1; j < circles.length; j++) {
                  circles[i].drawLine(ctx, circles[j]);
              }
          }
          if (current_circle.x) {
              current_circle.drawCircle(ctx);
              for (var k = 1; k < circles.length; k++) {
                  current_circle.drawLine(ctx, circles[k]);
              }
          }
          requestAnimationFrame(draw);
      };

      var init = function init(num) {
          for (var i = 0; i < num; i++) {
              circles.push(new Circle(Math.random() * w, Math.random() * h));
          }
          draw();
      };
      window.addEventListener('load', init(60));
      window.onmousemove = function (e) {
          e = e || window.event;
          current_circle.x = e.clientX;
          current_circle.y = e.clientY;
      };
      window.onmouseout = function () {
          current_circle.x = null;
          current_circle.y = null;
      };
  </script>
</body>
</html>
